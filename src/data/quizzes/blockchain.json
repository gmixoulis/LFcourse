{
  "Hyperledger_Fabric_Private_Exam_Bank": [
    {
      "question": "What is a key difference between permissioned and permissionless blockchains?",
      "options": [
        "A) Permissioned blockchains are faster but less secure",
        "B) Permissionless blockchains require known identities",
        "C) Permissioned blockchains have known, identified participants",
        "D) There is no significant difference"
      ],
      "correct_answer": "C",
      "explanation": "Permissioned blockchains like Hyperledger Fabric operate among known, identified participants under a governance model, while permissionless blockchains allow anonymous participation.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "What consensus mechanisms does Hyperledger Fabric support?",
      "options": [
        "A) Only Proof of Work (PoW)",
        "B) Only Byzantine Fault Tolerant (BFT)",
        "C) Pluggable consensus protocols including CFT and BFT",
        "D) Only Proof of Stake (PoS)"
      ],
      "correct_answer": "C",
      "explanation": "Fabric supports pluggable consensus protocols that can be tailored to specific use cases, including Crash Fault Tolerant (CFT) and Byzantine Fault Tolerant (BFT) consensus mechanisms.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What are smart contracts called in Hyperledger Fabric?",
      "options": ["A) Contracts", "B) Chaincode", "C) Scripts", "D) Modules"],
      "correct_answer": "B",
      "explanation": "In Hyperledger Fabric, smart contracts are called 'chaincode' and can be written in general-purpose programming languages like Go, Java, and Node.js.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "What is the role of an orderer in Hyperledger Fabric?",
      "options": [
        "A) Execute chaincode and maintain the ledger",
        "B) Establish consensus on transaction order and broadcast blocks",
        "C) Validate transactions and update the world state",
        "D) Manage user identities and certificates"
      ],
      "correct_answer": "B",
      "explanation": "The ordering service (orderer) establishes consensus on the order of transactions and broadcasts blocks to peers. It's responsible for creating the immutable sequence of transaction blocks.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What are the two types of peers in Hyperledger Fabric based on their roles?",
      "options": [
        "A) Client peers and server peers",
        "B) Primary peers and secondary peers",
        "C) Endorsing peers and committing peers",
        "D) Active peers and passive peers"
      ],
      "correct_answer": "C",
      "explanation": "Peers can be categorized as endorsing peers (which execute and endorse transactions) and committing peers (which validate and commit transactions to the ledger). All peers can be committing peers.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/peers/peers.html"
    },
    {
      "question": "What is the difference between local MSP and channel MSP?",
      "options": [
        "A) Local MSP is for peers, Channel MSP is for orderers",
        "B) Local MSP is node-specific, Channel MSP defines channel participants",
        "C) There is no difference between them",
        "D) Local MSP is encrypted, Channel MSP is not"
      ],
      "correct_answer": "B",
      "explanation": "Local MSP belongs to a specific node and is used for node-specific operations, while Channel MSP defines all organizations that participate in a particular channel.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/msp.html"
    },
    {
      "question": "What is the chaincode lifecycle in Hyperledger Fabric 2.x?",
      "options": [
        "A) Install → Instantiate → Invoke",
        "B) Package → Install → Approve → Commit",
        "C) Deploy → Activate → Execute",
        "D) Create → Upload → Run"
      ],
      "correct_answer": "B",
      "explanation": "Hyperledger Fabric 2.x introduced a new chaincode lifecycle: Package → Install → Approve → Commit, which enables decentralized governance for smart contracts.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/peerlifecycle.html"
    },
    {
      "question": "Which programming languages can be used to write chaincode in Hyperledger Fabric?",
      "options": [
        "A) Only Solidity",
        "B) Go, Java, and Node.js",
        "C) Only Go and Python",
        "D) Any programming language"
      ],
      "correct_answer": "B",
      "explanation": "Hyperledger Fabric supports chaincode development in general-purpose programming languages including Go, Java, and Node.js (JavaScript).",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "What is an endorsement policy?",
      "options": [
        "A) A rule that defines which peers must endorse a transaction",
        "B) A method for encrypting transaction data",
        "C) A consensus algorithm for ordering transactions",
        "D) A database indexing strategy"
      ],
      "correct_answer": "A",
      "explanation": "An endorsement policy specifies which peers (or how many) need to endorse a transaction for it to be valid. It defines the required endorsements for transaction validation.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html"
    },
    {
      "question": "What happens during the chaincode endorsement process?",
      "options": [
        "A) Peers vote on whether to accept the chaincode",
        "B) Peers execute the chaincode and cryptographically sign the results",
        "C) The orderer validates the chaincode logic",
        "D) The client application approves the chaincode"
      ],
      "correct_answer": "B",
      "explanation": "During endorsement, endorsing peers execute the chaincode, simulate the transaction, and cryptographically sign the results if they agree with the execution outcome.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "What is state-based endorsement in Hyperledger Fabric?",
      "options": [
        "A) Endorsement policies that apply to the entire chaincode",
        "B) Endorsement policies that can be set for individual keys/assets",
        "C) A consensus mechanism for state validation",
        "D) A method for state database optimization"
      ],
      "correct_answer": "B",
      "explanation": "State-based endorsement allows setting endorsement policies for individual keys or assets, providing more granular control over who can modify specific data.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "What is the Fabric Gateway service introduced in Hyperledger Fabric v2.4?",
      "options": [
        "A) A new consensus mechanism",
        "B) A simplified API that moves transaction processing to the peer",
        "C) A database management system",
        "D) An identity management service"
      ],
      "correct_answer": "B",
      "explanation": "The Fabric Gateway service provides a simplified API by moving node connection and transaction processing requirements from client applications to the peer nodes.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/gateway.html"
    },
    {
      "question": "What is the difference between evaluateTransaction and submitTransaction in Fabric Gateway APIs?",
      "options": [
        "A) evaluateTransaction modifies the ledger, submitTransaction queries it",
        "B) evaluateTransaction queries the ledger, submitTransaction modifies it",
        "C) Both functions do the same thing",
        "D) evaluateTransaction is deprecated"
      ],
      "correct_answer": "B",
      "explanation": "evaluateTransaction is used for read-only queries that don't modify the ledger state, while submitTransaction is used for transactions that update the ledger.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/gateway.html"
    },
    {
      "question": "What is offline signing in the Fabric Gateway client API?",
      "options": [
        "A) Signing transactions without internet connection",
        "B) A security feature that generates signatures from message digests without exposing private keys",
        "C) A backup method for transaction signing",
        "D) Signing transactions after they are committed"
      ],
      "correct_answer": "B",
      "explanation": "Offline signing allows cryptographic signatures to be generated from message digests without exposing private keys directly on the client side, enhancing security.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/gateway.html"
    },
    {
      "question": "Which Fabric Gateway client APIs are available?",
      "options": [
        "A) Only Node.js",
        "B) Go, Node.js, and Java",
        "C) Only Java and Python",
        "D) All major programming languages"
      ],
      "correct_answer": "B",
      "explanation": "Fabric Gateway client APIs are available for Go, Node.js (JavaScript), and Java, providing developers with multiple language options.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/gateway.html"
    },
    {
      "question": "What is the purpose of private data collections in Hyperledger Fabric?",
      "options": [
        "A) To encrypt all transaction data",
        "B) To allow a subset of channel members to keep data private from others",
        "C) To improve transaction performance",
        "D) To backup transaction data"
      ],
      "correct_answer": "B",
      "explanation": "Private data collections allow a defined subset of organizations on a channel to endorse, commit, or query private data without creating separate channels.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "What information is stored on the main channel ledger when using private data collections?",
      "options": [
        "A) The complete private data",
        "B) Only metadata about the private data",
        "C) A hash of the private data",
        "D) No information is stored"
      ],
      "correct_answer": "C",
      "explanation": "When using private data collections, only a hash of the private data is stored on the main channel ledger, while the actual private data is stored separately on authorized peers.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "What is the 'blockToLive' property in private data collection configuration?",
      "options": [
        "A) The number of blocks the collection will exist",
        "B) The number of blocks after which private data is automatically purged",
        "C) The maximum block size for private data",
        "D) The number of backup blocks to maintain"
      ],
      "correct_answer": "B",
      "explanation": "The 'blockToLive' property specifies how long private data should remain in the private database in terms of blocks before being automatically purged.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "In a production Hyperledger Fabric environment, what requires ongoing monitoring?",
      "options": [
        "A) Only the orderer service",
        "B) Only chaincode containers",
        "C) All peer containers including CPU, network, and memory",
        "D) Only peers running chaincode"
      ],
      "correct_answer": "C",
      "explanation": "In production, comprehensive monitoring of all peer containers is essential, including CPU, network, and memory usage to maintain optimal network performance and reliability.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/operations_service.html"
    },
    {
      "question": "What is the recommended ordering service for production deployments?",
      "options": [
        "A) Solo (single orderer)",
        "B) Kafka-based ordering",
        "C) Raft-based ordering",
        "D) Any ordering service is fine"
      ],
      "correct_answer": "C",
      "explanation": "Raft-based ordering service is recommended for production deployments due to its fault tolerance, scalability, and simpler operational characteristics compared to Kafka.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What security considerations are important for Hyperledger Fabric production networks?",
      "options": [
        "A) Only network firewalls",
        "B) TLS encryption, PKI management, and access controls",
        "C) Only user authentication",
        "D) Only data encryption"
      ],
      "correct_answer": "B",
      "explanation": "Production Fabric networks require comprehensive security including TLS encryption for communications, proper PKI certificate management, and appropriate access controls.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/security_model.html"
    },
    {
      "question": "Which command is used to calculate the package ID for a chaincode package?",
      "options": [
        "A) peer lifecycle chaincode calculatepackageid",
        "B) peer lifecycle chaincode querypackageid",
        "C) peer lifecycle chaincode getpackageid",
        "D) peer lifecycle chaincode packageid"
      ],
      "correct_answer": "A",
      "explanation": "The peer lifecycle chaincode calculatepackageid command calculates the package ID for a packaged chaincode.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/peerlifecycle.html"
    },
    {
      "question": "What does the fabric-ca-client affiliation list command do?",
      "options": [
        "A) Lists all users in the CA",
        "B) Lists all certificates issued",
        "C) Lists the affiliations table from CA database",
        "D) Lists all organizations in the network"
      ],
      "correct_answer": "C",
      "explanation": "The fabric-ca-client affiliation list command displays the affiliations table from the CA database.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/fabric-ca-commands.html"
    },
    {
      "question": "Which flag is used with configtxgen to specify the profile from configtx.yaml?",
      "options": [
        "A) -config",
        "B) -profile",
        "C) -template",
        "D) -configProfile"
      ],
      "correct_answer": "B",
      "explanation": "The -profile flag specifies which profile from configtx.yaml to use for generation.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "What does the peer channel getinfo command provide?",
      "options": [
        "A) Channel member list",
        "B) Blockchain information of a specified channel",
        "C) Channel configuration details",
        "D) Chaincode list on the channel"
      ],
      "correct_answer": "B",
      "explanation": "The peer channel getinfo command provides blockchain information of a specified channel including height and current block hash.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "Which osnadmin command lists channels that an orderer has joined?",
      "options": [
        "A) osnadmin channel show",
        "B) osnadmin channel query",
        "C) osnadmin channel list",
        "D) osnadmin channel info"
      ],
      "correct_answer": "C",
      "explanation": "The osnadmin channel list command shows all channels that the ordering service node has joined.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/create_channel/create_channel_participation.html"
    },
    {
      "question": "What is the role of Membership Service Provider (MSP) in Hyperledger Fabric?",
      "options": [
        "A) To order transactions into blocks",
        "B) To provide identity validation and authentication services",
        "C) To store chaincode",
        "D) To manage consensus protocols"
      ],
      "correct_answer": "B",
      "explanation": "MSP provides identity validation and authentication services by defining the rules for validating identities and determining member privileges.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/msp.html"
    },
    {
      "question": "What happens during the endorsement phase of transaction flow?",
      "options": [
        "A) Transactions are ordered into blocks",
        "B) Peers execute chaincode and generate read/write sets",
        "C) Transactions are validated against endorsement policies",
        "D) Blocks are committed to the ledger"
      ],
      "correct_answer": "B",
      "explanation": "During endorsement, peers execute the chaincode simulation and generate read/write sets along with endorsement signatures.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "What is the purpose of anchor peers in Hyperledger Fabric?",
      "options": [
        "A) To endorse all transactions",
        "B) To order transactions",
        "C) To facilitate cross-organization gossip communication",
        "D) To store channel configuration"
      ],
      "correct_answer": "C",
      "explanation": "Anchor peers facilitate gossip communication between organizations by serving as entry points for peers from other organizations.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/peers/peers.html"
    },
    {
      "question": "What is the difference between world state and blockchain in Fabric?",
      "options": [
        "A) World state is the current values, blockchain is the transaction history",
        "B) World state is encrypted, blockchain is not",
        "C) World state is temporary, blockchain is permanent",
        "D) There is no difference"
      ],
      "correct_answer": "A",
      "explanation": "World state represents current values of all keys, while blockchain contains the immutable transaction history that created those values.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "What is the purpose of the configtxlator tool?",
      "options": [
        "A) To generate genesis blocks",
        "B) To translate between protobuf and JSON formats for configuration",
        "C) To create channel transactions",
        "D) To validate configuration files"
      ],
      "correct_answer": "B",
      "explanation": "Configtxlator translates between protobuf and JSON representations, enabling human-readable configuration updates.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "What is the difference between invoke and query operations in chaincode?",
      "options": [
        "A) Invoke modifies state, query only reads state",
        "B) Invoke is faster than query",
        "C) Query requires endorsement, invoke does not",
        "D) There is no functional difference"
      ],
      "correct_answer": "A",
      "explanation": "Invoke operations can modify the world state and require endorsement, while query operations only read state and don't change it.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "What is chaincode shim in Hyperledger Fabric?",
      "options": [
        "A) A debugging tool for chaincode",
        "B) An interface layer between chaincode and peer",
        "C) A performance optimization technique",
        "D) A security validation mechanism"
      ],
      "correct_answer": "B",
      "explanation": "Chaincode shim provides the interface layer between user chaincode and the Fabric peer, handling communication and state access.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },

    {
      "question": "What is the purpose of the Init function in chaincode?",
      "options": [
        "A) To handle regular transactions",
        "B) To initialize chaincode when first deployed or upgraded",
        "C) To query the current state",
        "D) To validate endorsement policies"
      ],
      "correct_answer": "B",
      "explanation": "The Init function is called to initialize chaincode state when it's first deployed or when upgrading to a version that requires initialization.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "What happens when chaincode execution results in a panic or error?",
      "options": [
        "A) The transaction is automatically retried",
        "B) The transaction proposal response indicates failure",
        "C) The peer shuts down",
        "D) The error is ignored"
      ],
      "correct_answer": "B",
      "explanation": "When chaincode execution fails, the transaction proposal response indicates the failure, and the transaction is not endorsed.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "In private data collection, what is the memberOnlyRead policy used for?",
      "options": [
        "A) To restrict read access to collection members only",
        "B) To allow only one member to read at a time",
        "C) To enable read-only transactions",
        "D) To configure read permissions for non-members"
      ],
      "correct_answer": "A",
      "explanation": "The memberOnlyRead policy restricts read access to private data collection only to organizations that are members of the collection.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "Where is private data temporarily stored during endorsement?",
      "options": [
        "A) In the channel ledger",
        "B) In the ordering service",
        "C) In a transient data store",
        "D) In the world state database"
      ],
      "correct_answer": "C",
      "explanation": "During endorsement, private data is temporarily stored in a transient data store local to the peer before being distributed to authorized peers.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "What is the purpose of maxPeerCount in private data collections?",
      "options": [
        "A) Maximum peers that can be collection members",
        "B) Maximum peers for data redundancy distribution",
        "C) Maximum peers required for endorsement",
        "D) Maximum peers in gossip network"
      ],
      "correct_answer": "B",
      "explanation": "maxPeerCount defines the number of other peers that the endorsing peer will attempt to distribute private data to for redundancy.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "Can private data collections be added to an existing chaincode without upgrading?",
      "options": [
        "A) Yes, they can be added dynamically",
        "B) No, chaincode must be upgraded to add collections",
        "C) Only if approved by all organizations",
        "D) Only during channel creation"
      ],
      "correct_answer": "B",
      "explanation": "Adding private data collections requires upgrading the chaincode definition with the new collection configuration.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "What validation occurs for private data collection policies?",
      "options": [
        "A) Collection policy must be stricter than chaincode endorsement policy",
        "B) Collection policy must be the same as chaincode endorsement policy",
        "C) Collection policy must include all channel members",
        "D) Collection policy cannot be more restrictive than chaincode endorsement policy"
      ],
      "correct_answer": "D",
      "explanation": "Private data collection policies cannot be more restrictive than the chaincode endorsement policy to ensure proper endorsement.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "What factors affect Hyperledger Fabric network throughput?",
      "options": [
        "A) Only block size and batch timeout",
        "B) Block size, batch timeout, endorsement policy, and network latency",
        "C) Only the number of peer nodes",
        "D) Only the consensus algorithm used"
      ],
      "correct_answer": "B",
      "explanation": "Network throughput is affected by multiple factors including block size, batch timeout, endorsement policy complexity, and network latency between nodes.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html"
    },
    {
      "question": "What is the recommended approach for handling high transaction volumes?",
      "options": [
        "A) Increase block size only",
        "B) Decrease batch timeout only",
        "C) Optimize endorsement policies and use multiple channels",
        "D) Add more orderer nodes"
      ],
      "correct_answer": "C",
      "explanation": "For high volumes, optimize endorsement policies to reduce complexity and use multiple channels to parallelize transaction processing.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "How does the number of endorsing peers affect transaction latency?",
      "options": [
        "A) More endorsers always increase latency",
        "B) More endorsers always decrease latency",
        "C) More endorsers increase latency due to additional network calls",
        "D) Number of endorsers has no effect on latency"
      ],
      "correct_answer": "C",
      "explanation": "More endorsing peers increase transaction latency because the client must collect endorsements from additional peers over the network.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/peers/peers.html"
    },
    {
      "question": "What is the impact of rich queries on CouchDB performance?",
      "options": [
        "A) They have no performance impact",
        "B) They improve performance by using indexes",
        "C) They can significantly slow down queries without proper indexing",
        "D) They only work with simple key-value queries"
      ],
      "correct_answer": "C",
      "explanation": "Rich queries without proper indexing can significantly slow down CouchDB performance, so indexes should be created for frequently queried fields.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/couchdb_tutorial.html"
    },
    {
      "question": "What is the default PreferredMaxBytes value in orderer configuration?",
      "options": ["A) 512 KB", "B) 1 MB", "C) 2 MB", "D) 5 MB"],
      "correct_answer": "C",
      "explanation": "The default PreferredMaxBytes in configtx.yaml is set to 2 MB for optimal block size management.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What cryptographic algorithm does Hyperledger Fabric use for digital signatures?",
      "options": [
        "A) RSA",
        "B) DSA",
        "C) ECDSA with P-256 curve",
        "D) Ed25519"
      ],
      "correct_answer": "C",
      "explanation": "Hyperledger Fabric uses ECDSA (Elliptic Curve Digital Signature Algorithm) with the P-256 curve for digital signatures.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/security_model.html"
    },
    {
      "question": "What is Idemix in Hyperledger Fabric?",
      "options": [
        "A) A consensus algorithm",
        "B) A cryptographic protocol suite for anonymous credentials",
        "C) A chaincode development framework",
        "D) A performance monitoring tool"
      ],
      "correct_answer": "B",
      "explanation": "Idemix is a cryptographic protocol suite that enables anonymous credentials and unlinkable transactions using zero-knowledge proofs.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/security_model.html"
    },
    {
      "question": "What is the purpose of mutual TLS in Hyperledger Fabric?",
      "options": [
        "A) To encrypt data at rest",
        "B) To provide bidirectional authentication between network components",
        "C) To improve network performance",
        "D) To enable cross-channel communication"
      ],
      "correct_answer": "B",
      "explanation": "Mutual TLS provides bidirectional authentication where both client and server authenticate each other using certificates.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/security_model.html"
    },
    {
      "question": "What happens when a peer's TLS certificate expires?",
      "options": [
        "A) The peer continues to operate normally",
        "B) The peer cannot communicate with other network components",
        "C) Only endorsement operations are affected",
        "D) The peer automatically generates a new certificate"
      ],
      "correct_answer": "B",
      "explanation": "When a peer's TLS certificate expires, it cannot establish secure connections with other network components, causing a production outage.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/security_model.html"
    },
    {
      "question": "How are transaction proposals protected in Hyperledger Fabric?",
      "options": [
        "A) They are encrypted with AES",
        "B) They are signed by the client's private key",
        "C) They are hashed using SHA-256",
        "D) They are transmitted in plain text"
      ],
      "correct_answer": "B",
      "explanation": "Transaction proposals are signed by the client's private key to ensure authenticity and prevent tampering.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "What is the FABRIC_CFG_PATH environment variable used for?",
      "options": [
        "A) To specify the chaincode installation path",
        "B) To specify the path containing configuration files",
        "C) To specify the peer binary location",
        "D) To specify the channel artifacts path"
      ],
      "correct_answer": "B",
      "explanation": "FABRIC_CFG_PATH specifies the path where configuration files like configtx.yaml and core.yaml are located.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "What is the purpose of the Bootstrap Admin in Fabric CA?",
      "options": [
        "A) To endorse transactions",
        "B) To order blocks",
        "C) To be the initial administrator identity for CA server startup",
        "D) To manage peer nodes"
      ],
      "correct_answer": "C",
      "explanation": "The Bootstrap Admin (-b option) is the initial administrator identity required to start the Fabric CA server and register other identities.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/fabric-ca-commands.html"
    },
    {
      "question": "What does the --tls flag do in Fabric CLI commands?",
      "options": [
        "A) Enables TLS encryption for client-server communication",
        "B) Generates new TLS certificates",
        "C) Validates existing TLS certificates",
        "D) Disables TLS for testing"
      ],
      "correct_answer": "A",
      "explanation": "The --tls flag enables TLS encryption when the CLI communicates with network components like peers and orderers.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What is the role of the configtx.yaml file?",
      "options": [
        "A) To define peer configuration",
        "B) To define channel and consortium configuration",
        "C) To define chaincode parameters",
        "D) To define user credentials"
      ],
      "correct_answer": "B",
      "explanation": "The configtx.yaml file defines channel configurations, consortium settings, and profiles used by configtxgen to create channel artifacts.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "What validation is performed when committing a chaincode definition?",
      "options": [
        "A) Only package ID validation",
        "B) LifecycleEndorsement policy satisfaction and parameter consistency",
        "C) Only endorsement policy syntax check",
        "D) Only sequence number validation"
      ],
      "correct_answer": "B",
      "explanation": "When committing a chaincode definition, Fabric validates that the LifecycleEndorsement policy is satisfied and parameters are consistent across approvals.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html"
    },
    {
      "question": "According to the Hyperledger Fabric documentation, what is the default validity period for Organization CA Root Certificates?",
      "options": ["A) 5 years", "B) 10 years", "C) 15 years", "D) 20 years"],
      "correct_answer": "C",
      "explanation": "Organization CA Root Certificates are valid for 15 years by default, as specified in the certificate management documentation.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/security_model.html"
    },
    {
      "question": "Which configuration parameter must be set in fabric-ca-server-config.yaml to allow renewal of expired certificates?",
      "options": [
        "A) allowExpiredRenewal: true",
        "B) enableExpiredCertRenewal: true",
        "C) reenrollignorecertexpiry: true",
        "D) ignoreExpiredCerts: true"
      ],
      "correct_answer": "C",
      "explanation": "The reenrollignorecertexpiry parameter must be set to true in the CA configuration to allow renewal of expired certificates.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/fabric-ca-commands.html"
    },
    {
      "question": "What is the default validity period for Client Certificates using Hyperledger Fabric CA default settings?",
      "options": ["A) 6 months", "B) 1 year", "C) 2 years", "D) 5 years"],
      "correct_answer": "B",
      "explanation": "Client Certificates expire after one year using the Hyperledger Fabric CA default settings.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/fabric-ca-commands.html"
    },
    {
      "question": "Which fabric-ca-client command is used to view the users table in the CA database?",
      "options": [
        "A) fabric-ca-client user list",
        "B) fabric-ca-client identity list",
        "C) fabric-ca-client query users",
        "D) fabric-ca-client show identities"
      ],
      "correct_answer": "B",
      "explanation": "The fabric-ca-client identity list command is used to view the users table in the CA database.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/fabric-ca-commands.html"
    },
    {
      "question": "What is the default database file name used by fabric-ca-server when using SQLite?",
      "options": [
        "A) fabric-ca.db",
        "B) fabric-ca-server.db",
        "C) ca-database.db",
        "D) hyperledger-ca.db"
      ],
      "correct_answer": "B",
      "explanation": "By default, the fabric-ca-server uses SQLite with the database file named fabric-ca-server.db in the home directory.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/fabric-ca-commands.html"
    },
    {
      "question": "Which peer lifecycle chaincode subcommand is used to check if a chaincode definition is ready to be committed?",
      "options": [
        "A) peer lifecycle chaincode querycommitted",
        "B) peer lifecycle chaincode checkcommitreadiness",
        "C) peer lifecycle chaincode queryapproved",
        "D) peer lifecycle chaincode queryinstalled"
      ],
      "correct_answer": "B",
      "explanation": "The peer lifecycle chaincode checkcommitreadiness command checks if a chaincode definition is ready to be committed to a channel.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/peerlifecycle.html"
    },
    {
      "question": "What does the configtxgen -printOrg command do?",
      "options": [
        "A) Prints all organizations in the network",
        "B) Prints the definition of an organization as JSON",
        "C) Prints organization certificates",
        "D) Prints organization peer lists"
      ],
      "correct_answer": "B",
      "explanation": "The configtxgen -printOrg command prints the definition of an organization as JSON, useful for adding an org to a channel manually.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "Which osnadmin command is used to join an orderer to a channel in Fabric v2.3+?",
      "options": [
        "A) osnadmin channel create",
        "B) osnadmin channel join",
        "C) osnadmin channel add",
        "D) osnadmin channel connect"
      ],
      "correct_answer": "B",
      "explanation": "The osnadmin channel join command is used to join an Ordering Service Node (OSN) to a channel.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/create_channel/create_channel_participation.html"
    },
    {
      "question": "What is the purpose of the cryptogen tool in Hyperledger Fabric?",
      "options": [
        "A) To generate chaincode packages",
        "B) To create channel configuration transactions",
        "C) To generate cryptographic material (certificates and keys)",
        "D) To encrypt transaction data"
      ],
      "correct_answer": "C",
      "explanation": "The cryptogen tool is used to generate cryptographic material including certificates and keys for organizations and their components.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/security_model.html"
    },
    {
      "question": "Which peer channel command is used to fetch a specific block from a channel?",
      "options": [
        "A) peer channel get",
        "B) peer channel fetch",
        "C) peer channel retrieve",
        "D) peer channel download"
      ],
      "correct_answer": "B",
      "explanation": "The peer channel fetch command is used to fetch a block from a channel. You can specify block numbers or use 'config' for the latest config block.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "What is the execute-order-validate architecture in Hyperledger Fabric?",
      "options": [
        "A) Transactions are ordered first, then executed and validated",
        "B) Transactions are executed first, then ordered, then validated",
        "C) Transactions are validated first, then executed and ordered",
        "D) All three phases happen simultaneously"
      ],
      "correct_answer": "B",
      "explanation": "Hyperledger Fabric uses the execute-order-validate architecture where transactions are first executed (endorsed) by peers, then ordered by the ordering service, and finally validated before being committed to the ledger.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "In Hyperledger Fabric, what is the role of endorsing peers?",
      "options": [
        "A) They order transactions into blocks",
        "B) They execute chaincode and sign transaction proposals",
        "C) They store the blockchain data",
        "D) They manage user identities"
      ],
      "correct_answer": "B",
      "explanation": "Endorsing peers execute chaincode against the ledger state and sign (endorse) the transaction proposal response with their digital signature.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "What is a channel in Hyperledger Fabric?",
      "options": [
        "A) A communication protocol between peers",
        "B) A private subnet of communication between specific network members",
        "C) A storage mechanism for chaincode",
        "D) A consensus algorithm"
      ],
      "correct_answer": "B",
      "explanation": "A channel in Hyperledger Fabric is a private subnet of communication between specific network members, providing data isolation and confidentiality.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "What happens when a peer receives a block during the validation phase?",
      "options": [
        "A) It immediately commits the block to the ledger",
        "B) It validates endorsements and checks for conflicts before committing",
        "C) It forwards the block to other peers",
        "D) It executes the transactions in the block"
      ],
      "correct_answer": "B",
      "explanation": "During validation, peers check endorsement policies, validate signatures, and perform MVCC (Multi-Version Concurrency Control) checks before committing valid transactions to the ledger.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/peers/peers.html"
    },
    {
      "question": "What is the required format for chaincode packages in Fabric 2.0+ lifecycle?",
      "options": [
        "A) .zip file with source code and metadata",
        "B) .tar.gz file with metadata.json and code.tar.gz",
        "C) .jar file for Java chaincode",
        "D) .docker file with containerized code"
      ],
      "correct_answer": "B",
      "explanation": "Chaincode packages in Fabric 2.0+ must be in .tar.gz format containing metadata.json and code.tar.gz files.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/peerlifecycle.html"
    },
    {
      "question": "What is the purpose of the sequence number in chaincode lifecycle?",
      "options": [
        "A) To identify the chaincode version",
        "B) To track chaincode upgrades and definition changes",
        "C) To set execution order",
        "D) To determine endorsement requirements"
      ],
      "correct_answer": "B",
      "explanation": "The sequence number tracks upgrades and changes to the chaincode definition. It must be incremented for each change to the chaincode definition.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode_lifecycle.html"
    },
    {
      "question": "Which chaincode language shows the best performance in Hyperledger Fabric?",
      "options": ["A) Java", "B) Node.js", "C) Go", "D) Python"],
      "correct_answer": "C",
      "explanation": "Go chaincode has shown the best performance in Hyperledger Fabric, followed by Node.js, then Java. Python is not officially supported.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "How would a developer test chaincode iteratively without the full lifecycle process?",
      "options": [
        "A) Deploy to production network",
        "B) Run chaincode in development mode",
        "C) Use a test blockchain",
        "D) Manual code updates on peers"
      ],
      "correct_answer": "B",
      "explanation": "Running chaincode in development mode allows developers to test and debug without the overhead of packaging, installing, approving, and committing for each update.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode_lifecycle.html"
    },
    {
      "question": "What happens when delState('A') function is committed in a transaction?",
      "options": [
        "A) The key 'A' is completely removed from all records",
        "B) The key 'A' is set to null value",
        "C) The state of key 'A' is removed from state database but history remains in ledger",
        "D) All transaction history for key 'A' is deleted"
      ],
      "correct_answer": "C",
      "explanation": "When delState('A') is committed, the current state of key 'A' is removed from the state database, but the transaction history remains in the immutable ledger.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "What is the default SendBufferSize value for orderer nodes in Hyperledger Fabric v2.5?",
      "options": ["A) 10", "B) 50", "C) 100", "D) 500"],
      "correct_answer": "C",
      "explanation": "In Fabric v2.5, the default SendBufferSize was changed from 10 to 100 to improve throughput.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What is the maximum recommended size for AbsoluteMaxBytes in block cutting parameters?",
      "options": ["A) 10 MB", "B) 25 MB", "C) 49 MB", "D) 100 MB"],
      "correct_answer": "C",
      "explanation": "The maximum recommended size is 49 MB, based on the headroom needed for the default grpc max message size of 100 MB.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/key_concepts.html"
    },
    {
      "question": "What is the minimum recommended network connectivity speed between Fabric nodes?",
      "options": ["A) 100 Mbps", "B) 500 Mbps", "C) 1 Gbps", "D) 10 Gbps"],
      "correct_answer": "C",
      "explanation": "A minimum of 1 Gbps should be deployed between all nodes and organizations for optimal performance.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/key_concepts.html"
    },
    {
      "question": "What is the default BatchTimeout value in orderer configuration?",
      "options": [
        "A) 1 second",
        "B) 2 seconds",
        "C) 5 seconds",
        "D) 10 seconds"
      ],
      "correct_answer": "B",
      "explanation": "The default BatchTimeout value is 2 seconds, which determines how long to wait before cutting a block.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What is the default MaxMessageCount value in block cutting parameters?",
      "options": ["A) 100", "B) 250", "C) 500", "D) 1000"],
      "correct_answer": "C",
      "explanation": "The default MaxMessageCount is 500, which sets the maximum number of transactions in a single block.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/key_concepts.html"
    },
    {
      "question": "In a Byzantine Fault Tolerant consensus protocol, what is the minimum number of nodes required to tolerate F faulty nodes?",
      "options": ["A) F + 1", "B) 2F + 1", "C) 3F + 1", "D) 4F + 1"],
      "correct_answer": "C",
      "explanation": "Byzantine Fault Tolerance requires 3F + 1 nodes to tolerate F Byzantine (malicious) failures.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "For a Raft cluster with 5 orderer nodes, how many nodes must be available for the service to function?",
      "options": ["A) 2", "B) 3", "C) 4", "D) 5"],
      "correct_answer": "B",
      "explanation": "Raft requires a majority (N/2 + 1) to function. For 5 nodes, at least 3 nodes must be available.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "How many orderer nodes are adequate for a test Ordering Service?",
      "options": [
        "A) No set requirement",
        "B) Three ordering nodes minimum",
        "C) One ordering node is sufficient",
        "D) Ordering nodes are optional"
      ],
      "correct_answer": "C",
      "explanation": "For a test network, one ordering node is sufficient. Production networks should use multiple nodes for fault tolerance.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "Which consensus mechanism was deprecated in favor of Raft in Hyperledger Fabric?",
      "options": ["A) PBFT", "B) Kafka", "C) Solo", "D) Istanbul BFT"],
      "correct_answer": "B",
      "explanation": "Kafka-based ordering was deprecated in favor of Raft consensus, which provides better crash fault tolerance and doesn't require a separate Kafka cluster.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What type of consensus does Hyperledger Fabric's Raft implementation provide?",
      "options": [
        "A) Byzantine Fault Tolerance (BFT)",
        "B) Crash Fault Tolerance (CFT)",
        "C) Practical Byzantine Fault Tolerance (pBFT)",
        "D) Proof of Work (PoW)"
      ],
      "correct_answer": "B",
      "explanation": "Fabric's Raft implementation provides Crash Fault Tolerance (CFT), which can handle node crashes but not malicious/Byzantine behavior.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "Which parameter in a private data collection configuration determines data retention period?",
      "options": [
        "A) timeToLive",
        "B) blockToLive",
        "C) dataRetention",
        "D) purgeAfter"
      ],
      "correct_answer": "B",
      "explanation": "The blockToLive parameter specifies how many blocks the private data should be stored before being purged.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "What does blockToLive set to 0 mean in private data collection configuration?",
      "options": [
        "A) Data is purged immediately",
        "B) Data is purged after block 0",
        "C) Data is never purged and kept indefinitely",
        "D) Data is purged after 10 blocks by default"
      ],
      "correct_answer": "C",
      "explanation": "Setting blockToLive to 0 means private data will never be purged and kept indefinitely.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "In private data collections, what is the purpose of requiredPeerCount?",
      "options": [
        "A) Maximum peers that can access the collection",
        "B) Minimum peers required for endorsement",
        "C) Minimum peers required for dissemination",
        "D) Number of peers in the channel"
      ],
      "correct_answer": "C",
      "explanation": "requiredPeerCount specifies the minimum number of peers (besides the endorsing peer) that must receive the private data.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "What is stored on the channel ledger for private data transactions?",
      "options": [
        "A) The actual private data",
        "B) An encrypted version of private data",
        "C) A hash of the private data",
        "D) A reference pointer to private data"
      ],
      "correct_answer": "C",
      "explanation": "Only a hash of the private data is stored on the channel ledger, serving as evidence of the transaction while keeping the data private.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "Which API should be used to completely remove private data from all peers?",
      "options": [
        "A) DelPrivateData",
        "B) RemovePrivateData",
        "C) PurgePrivateData",
        "D) ClearPrivateData"
      ],
      "correct_answer": "C",
      "explanation": "PurgePrivateData API completely removes private data from all peers, while DelPrivateData only removes from state database.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "Which MSP roles are valid in Hyperledger Fabric endorsement policy syntax?",
      "options": [
        "A) member, admin, client, peer, validator",
        "B) member, admin, client, peer",
        "C) member, admin, peer, orderer",
        "D) member, client, peer, validator"
      ],
      "correct_answer": "B",
      "explanation": "The four accepted roles are: member, admin, client, and peer. 'Validator' is not a valid MSP role.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html"
    },
    {
      "question": "What is the default chaincode endorsement policy if none is specified?",
      "options": [
        "A) Channel/Application/Admins",
        "B) Channel/Application/Endorsement",
        "C) Channel/Application/LifecycleEndorsement",
        "D) Channel/Application/Majority"
      ],
      "correct_answer": "B",
      "explanation": "If no policy is specified, the chaincode definition uses the Channel/Application/Endorsement policy by default.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html"
    },
    {
      "question": "What does the endorsement policy OutOf(2, 'Org1.member', 'Org2.member', 'Org3.member') require?",
      "options": [
        "A) All three organizations must endorse",
        "B) Any two out of the three organizations must endorse",
        "C) Only Org1 and Org2 must endorse",
        "D) At least one organization must endorse"
      ],
      "correct_answer": "B",
      "explanation": "OutOf(2, ...) requires any 2 out of the 3 specified organizations to endorse the transaction.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html"
    },
    {
      "question": "What is the default LifecycleEndorsement policy for chaincode definition approval?",
      "options": [
        "A) Any organization can approve",
        "B) Majority of organizations must approve",
        "C) All organizations must approve",
        "D) Super-majority (2/3) must approve"
      ],
      "correct_answer": "B",
      "explanation": "The default LifecycleEndorsement policy requires a majority of channel members to approve a chaincode definition.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html"
    },
    {
      "question": "Which chaincode API is used to set key-level endorsement policies?",
      "options": [
        "A) SetEndorsementPolicy(key, policy)",
        "B) SetStateValidationParameter(key, ep)",
        "C) SetKeyPolicy(key, endorsers)",
        "D) SetStateEndorsement(key, orgs)"
      ],
      "correct_answer": "B",
      "explanation": "SetStateValidationParameter(key string, ep []byte) is the correct API for setting state-based (key-level) endorsement policies.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "What command is used to create a channel configuration transaction?",
      "options": [
        "A) configtxgen -outputCreateChannelTx",
        "B) peer channel create",
        "C) configtxgen -channelCreateTx",
        "D) osnadmin channel create"
      ],
      "correct_answer": "A",
      "explanation": "The configtxgen -outputCreateChannelTx command creates a channel configuration transaction file.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "Which tool is used to inspect the contents of a genesis block?",
      "options": [
        "A) configtxgen -inspectBlock",
        "B) peer channel inspect",
        "C) configtxlator decode",
        "D) osnadmin channel inspect"
      ],
      "correct_answer": "A",
      "explanation": "The configtxgen -inspectBlock command prints the contents of a genesis block as JSON.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "What is required for peers to receive blocks from a channel?",
      "options": [
        "A) Installing chaincode on the peer",
        "B) Calling the join channel API on each peer",
        "C) Adding peer to endorsement policy",
        "D) Configuring peer in configtx.yaml"
      ],
      "correct_answer": "B",
      "explanation": "In order for peers to receive blocks from a channel, you need to call the 'join channel API' on each peer using peer channel join command.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "In Fabric v2.3+, what feature allows channel creation without a system channel?",
      "options": [
        "A) Channel participation API using osnadmin CLI",
        "B) Direct peer channel creation",
        "C) Automated channel bootstrap",
        "D) Configless channel deployment"
      ],
      "correct_answer": "A",
      "explanation": "The osnadmin CLI with channel participation API allows creating channels without requiring a system channel starting from Fabric v2.3.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/create_channel/create_channel_participation.html"
    },
    {
      "question": "What information do signature policies provide when creating a network?",
      "options": [
        "A) Number of nodes in the network",
        "B) Identity of specific users who must sign to satisfy policy",
        "C) Private keys of network participants",
        "D) Type of consensus algorithm used"
      ],
      "correct_answer": "B",
      "explanation": "Signature policies specify the identities of specific users who must sign a transaction for it to be considered valid.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/key_concepts.html"
    },
    {
      "question": "In which version was the Peer Gateway Service first introduced?",
      "options": ["A) v2.2", "B) v2.3", "C) v2.4", "D) v2.5"],
      "correct_answer": "C",
      "explanation": "The Peer Gateway Service was first introduced in Hyperledger Fabric v2.4.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/gateway.html"
    },
    {
      "question": "What is the default gatewayService concurrency limit?",
      "options": ["A) 250", "B) 500", "C) 1000", "D) 2500"],
      "correct_answer": "B",
      "explanation": "The gatewayService has a default concurrency limit of 500 concurrent requests.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/key_concepts.html"
    },
    {
      "question": "What is the primary advantage of using Peer Gateway Service over legacy SDKs?",
      "options": [
        "A) Better chaincode execution performance",
        "B) Reduced client complexity and network connections",
        "C) Enhanced security through certificate pinning",
        "D) Support for more programming languages"
      ],
      "correct_answer": "B",
      "explanation": "The Gateway Service reduces client complexity by handling endorsement collection and reduces the number of network connections needed.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "What does the peer chaincode invoke command with --isInit flag do?",
      "options": [
        "A) Installs the chaincode",
        "B) Calls the Init function to initialize chaincode",
        "C) Invokes any chaincode function",
        "D) Initializes the peer node"
      ],
      "correct_answer": "B",
      "explanation": "The --isInit flag with peer chaincode invoke calls the Init function to initialize the chaincode.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "Which smart contract communication is limited in inter-contract scenarios?",
      "options": [
        "A) Chaincode X calls GetState in Chaincode Y on same channel",
        "B) Chaincode X calls PutState in Chaincode Y on same channel",
        "C) Chaincode X calls GetState in Chaincode Y on different channel",
        "D) Chaincode X calls PutState in Chaincode Y on different channel"
      ],
      "correct_answer": "D",
      "explanation": "Writing data (PutState) to a chaincode on a different channel is restricted for security and isolation reasons.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "Which state database provides better performance for high-throughput applications?",
      "options": ["A) CouchDB", "B) LevelDB", "C) MongoDB", "D) PostgreSQL"],
      "correct_answer": "B",
      "explanation": "LevelDB performance is noticeably faster than CouchDB, sometimes by a factor of 2x for high-throughput applications.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/couchdb_tutorial.html"
    },
    {
      "question": "What is the default CouchDB cache size for peer nodes?",
      "options": ["A) 32 MB", "B) 64 MB", "C) 128 MB", "D) 256 MB"],
      "correct_answer": "B",
      "explanation": "The default CouchDB cache size is 64 MB, and it must be a multiple of 32 MB.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/couchdb_tutorial.html"
    },
    {
      "question": "What is the default totalQueryLimit in a peer's core.yaml file?",
      "options": ["A) 10,000", "B) 50,000", "C) 100,000", "D) 1,000,000"],
      "correct_answer": "C",
      "explanation": "The default totalQueryLimit is 100,000 records to avoid larger than expected result sets that could slow down a peer.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/key_concepts.html"
    },
    {
      "question": "What happens to historic states in the Hyperledger Fabric ledger?",
      "options": [
        "A) They can be modified by administrators",
        "B) They require admin role for access",
        "C) They are immutable",
        "D) They cannot be accessed by anyone"
      ],
      "correct_answer": "C",
      "explanation": "Historic states in the Hyperledger Fabric ledger are immutable, meaning they cannot be altered after being committed.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "When using CouchDB, what additional capability does it provide over LevelDB?",
      "options": [
        "A) Better performance",
        "B) Rich queries using JSON query syntax",
        "C) Lower resource usage",
        "D) Built-in backup functionality"
      ],
      "correct_answer": "B",
      "explanation": "CouchDB enables rich queries against chaincode data using JSON query syntax, while LevelDB only supports key-based queries.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "What is the default listen address for the peer operations service?",
      "options": [
        "A) 127.0.0.1:8443",
        "B) 127.0.0.1:9443",
        "C) 0.0.0.0:8080",
        "D) localhost:7051"
      ],
      "correct_answer": "B",
      "explanation": "The default peer operations service listens on 127.0.0.1:9443, while orderer uses 127.0.0.1:8443.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "Which metrics provider options are available for Fabric operations service?",
      "options": [
        "A) prometheus, statsd, or disabled",
        "B) prometheus, grafana, or none",
        "C) statsd, influxdb, or disabled",
        "D) prometheus, elasticsearch, or off"
      ],
      "correct_answer": "A",
      "explanation": "Fabric operations service supports prometheus, statsd, or disabled as metrics provider options.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/operations_service.html"
    },
    {
      "question": "What is the recommended CPU threshold before scaling up peer resources?",
      "options": ["A) 50-60%", "B) 60-70%", "C) 70-80%", "D) 80-90%"],
      "correct_answer": "C",
      "explanation": "A threshold of 70-80% CPU usage is the general guideline for maximum workload before increasing resources.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/key_concepts.html"
    },
    {
      "question": "Which environment variable configures the operations service listen address for peers?",
      "options": [
        "A) CORE_PEER_OPERATIONS_ADDRESS",
        "B) CORE_OPERATIONS_LISTENADDRESS",
        "C) CORE_PEER_LISTENADDRESS",
        "D) FABRIC_OPERATIONS_ADDRESS"
      ],
      "correct_answer": "B",
      "explanation": "CORE_OPERATIONS_LISTENADDRESS is used to configure the operations service listen address for peers.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/operations_service.html"
    },
    {
      "question": "What endpoints are typically available on the Fabric operations service?",
      "options": [
        "A) /status, /info, /config",
        "B) /health, /metrics, /version",
        "C) /healthz, /metrics, /logspec",
        "D) /ping, /stats, /debug"
      ],
      "correct_answer": "C",
      "explanation": "The Fabric operations service provides /healthz for health checks, /metrics for monitoring data, and /logspec for log level management.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/operations_service.html"
    },
    {
      "question": "What is the TLSHandshakeTimeShift parameter used for in orderer configuration?",
      "options": [
        "A) To adjust network latency compensation",
        "B) To allow expired TLS certificates to form consensus temporarily",
        "C) To synchronize orderer node clocks",
        "D) To configure TLS handshake timeout values"
      ],
      "correct_answer": "B",
      "explanation": "TLSHandshakeTimeShift allows orderers with expired TLS certificates to temporarily form consensus for certificate updates.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What is the purpose of ImplicitMeta policies in channel configuration?",
      "options": [
        "A) To define explicit signature requirements",
        "B) To aggregate results from policies deeper in configuration hierarchy",
        "C) To create automatic policy inheritance",
        "D) To define default access control rules"
      ],
      "correct_answer": "B",
      "explanation": "ImplicitMeta policies aggregate results from policies deeper in the configuration hierarchy, like 'majority of organization admin policies'.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "What is the recommended general guideline for CPU and memory allocation to orderer nodes?",
      "options": [
        "A) 1 CPU with 1 GB Memory",
        "B) 1 CPU with 2 GB Memory",
        "C) 2 CPU with 2 GB Memory",
        "D) 2 CPU with 4 GB Memory"
      ],
      "correct_answer": "B",
      "explanation": "The general guideline for orderer nodes is 1 CPU with 2 GB of Memory for basic deployments.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What is the typical transaction size for a transaction with required endorsements?",
      "options": ["A) 1-2 KB", "B) 3-4 KB", "C) 5-6 KB", "D) 7-8 KB"],
      "correct_answer": "B",
      "explanation": "A minimum transaction size is around 1 KB, and adding 1 KB per required endorsement results in typical transactions of 3-4 KB.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/txflow.html"
    },
    {
      "question": "Which consensus mechanisms does Hyperledger Fabric's pluggable consensus support?",
      "options": [
        "A) Both Crash Fault Tolerant (CFT) and Byzantine Fault Tolerant (BFT)",
        "B) Only Crash Fault Tolerant (CFT)",
        "C) Only Byzantine Fault Tolerant (BFT)",
        "D) Only Practical Byzantine Fault Tolerance (pBFT)"
      ],
      "correct_answer": "A",
      "explanation": "Hyperledger Fabric's pluggable consensus architecture supports both CFT and BFT consensus mechanisms depending on deployment requirements.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What is the primary purpose of Private Data Collections in Hyperledger Fabric?",
      "options": [
        "A) To store public data more efficiently",
        "B) To enable private communication between blockchain networks",
        "C) To increase the transaction speed on the network",
        "D) To allow a subset of organizations to share confidential data"
      ],
      "correct_answer": "D",
      "explanation": "Private data collections let a defined subset of channel members share confidential key-value data without writing the data itself to the shared ledger.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "In a private data collection definition file, what does the property \"blockToLive\" specify?",
      "options": [
        "A) The maximum number of peers required to endorse the transaction",
        "B) The duration (in blocks) that private data should remain in the private database before being deleted",
        "C) The minimum number of peers needed to store the private data",
        "D) The total number of blocks needed to complete a private data transaction"
      ],
      "correct_answer": "B",
      "explanation": "blockToLive sets the data-retention window (in blocks). When the block height exceeds this value, matching private data is purged from the peer databases.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "Which function is used in Hyperledger Fabric chaincode to read private data from a private data collection?",
      "options": [
        "A) ReadPrivateData()",
        "B) QueryPrivateData()",
        "C) GetPrivateData()",
        "D) RetrievePrivateData()"
      ],
      "correct_answer": "C",
      "explanation": "Stub API stub.GetPrivateData(collection, key) retrieves a private value from a named collection.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "When transferring an asset between organizations in Hyperledger Fabric, which private data collections are involved in ensuring the appraised value is agreed upon before the transfer?",
      "options": [
        "A) Org1MSPPrivateCollection",
        "B) assetCollection and Org1MSPPrivateCollection",
        "C) Org1MSPPrivateCollection and Org2MSPPrivateCollection",
        "D) assetCollection, Org1MSPPrivateCollection, and Org2MSPPrivateCollection"
      ],
      "correct_answer": "D",
      "explanation": "During asset-transfer-private-data sample flow the shared assetCollection stores public properties, while Org1MSPPrivateCollection and Org2MSPPrivateCollection store each org’s private appraisal until both agree.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "What is the main advantage of using state-based endorsement policies instead of static endorsement policies in Hyperledger Fabric?",
      "options": [
        "A) State-based policies are easier to configure and deploy",
        "B) State-based policies are less resource-intensive and have lower gas costs",
        "C) State-based policies are simpler to understand and implement compared to static policies",
        "D) State-based policies provide greater flexibility by allowing different endorsement requirements for different types of data"
      ],
      "correct_answer": "D",
      "explanation": "State-based policies can be attached to individual keys, enabling per-asset endorsement requirements instead of one fixed rule for all chaincode operations.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "How does a state-based endorsement policy differ from a static endorsement policy in terms of application?",
      "options": [
        "A) State-based endorsement policies are applied uniformly across all transactions, while static policies are conditionally applied",
        "B) State-based endorsement policies are defined in the chaincode's lifecycle, while static policies are dynamic and can be changed at runtime",
        "C) State-based endorsement policies allow different endorsement requirements for different data states, while static policies apply the same requirements across all transactions",
        "D) State-based endorsement policies require fewer endorsements compared to static policies"
      ],
      "correct_answer": "C",
      "explanation": "Static (signature) policies sit in channel config/chaincode definition and apply to every key; state-based policies can override them per key, enabling different rules per asset.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html"
    },
    {
      "question": "Which environment variable needs to be set to interact with the Fabric network as a user from Org1?",
      "options": [
        "A) CORE_PEER_TLS_ENABLED",
        "B) CORE_PEER_LOCALMSPID",
        "C) CORE_PEER_ADDRESS",
        "D) FABRIC_CFG_PATH"
      ],
      "correct_answer": "B",
      "explanation": "CORE_PEER_LOCALMSPID sets the MSP ID (e.g., Org1MSP) so CLI commands present the correct organizational identity.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/msp.html"
    },
    {
      "question": "Which of the following is NOT a key security principle for Hyperledger Fabric?",
      "options": [
        "A) Least Privilege - Granting chaincode only the minimum permissions necessary",
        "B) Regular Updates - Keeping chaincode and platform up-to-date with security patches",
        "C) Decentralized Governance - Allowing all participants to control network security",
        "D) Secure Development Practices - Applying secure coding principles to chaincode"
      ],
      "correct_answer": "C",
      "explanation": "Fabric networks use permissioned governance models; “allow everyone to control security” violates least-privilege and trust-domain boundaries.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/security_model.html"
    },
    {
      "question": "In Hyperledger Fabric, what mechanism helps ensure that only authorized users can access specific data on the network?",
      "options": [
        "A) Role-Based Access Control (RBAC)",
        "B) Certificate Management",
        "C) Private Data Collections",
        "D) Network and Communication Security"
      ],
      "correct_answer": "C",
      "explanation": "Private data collections restrict key-value visibility to an authorized subset of orgs, enforced by each peer’s transient data store and access checks.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "What is the primary benefit of scaling nodes (adding peers or orderers) in a Hyperledger Fabric network?",
      "options": [
        "A) To enhance data privacy and confidentiality",
        "B) To strengthen network security by adding more access points",
        "C) To simplify the management and administration of the network",
        "D) To improve transaction throughput and handle increased load"
      ],
      "correct_answer": "D",
      "explanation": "More endorsing peers can process proposals in parallel and additional orderers increase block-generation capacity, raising overall throughput.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "Why is Transport Layer Security (TLS) important in a Hyperledger Fabric network?",
      "options": [
        "A) It speeds up data transmission between nodes",
        "B) It encrypts data to protect it from unauthorized access",
        "C) It increases the transaction throughput",
        "D) It manages the identities of network participants"
      ],
      "correct_answer": "B",
      "explanation": "TLS encrypts and authenticates gRPC traffic between Fabric components, protecting payloads and credentials in transit.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/security_model.html"
    },
    {
      "question": "What is the primary purpose of regular monitoring and maintenance in a Hyperledger Fabric network?",
      "options": [
        "A) To detect issues early and maintain optimal performance",
        "B) To enhance the visual appearance of dashboards",
        "C) To increase the complexity of network management",
        "D) To reduce the number of peer nodes"
      ],
      "correct_answer": "A",
      "explanation": "Observability (metrics, logs, health checks) allows administrators to detect anomalies early and keep the network operating within SLOs.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/operations_service.html"
    },
    {
      "question": "What is the purpose of a disaster recovery plan in a Hyperledger Fabric network?",
      "options": [
        "A) To permanently remove all data from the network",
        "B) To outline steps for quickly restoring the network after a failure",
        "C) To increase the number of nodes in the network",
        "D) To randomly change the network configuration"
      ],
      "correct_answer": "B",
      "explanation": "A documented DR plan enables rapid restoration of peer ledgers, ordering service and CA data after outages, minimizing downtime.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "Which of the following is NOT a key step in securing communication channels with TLS?",
      "options": [
        "A) Setting up a TLS Certificate Authority (CA)",
        "B) Generating TLS certificates for all components",
        "C) Configuring components to use TLS",
        "D) Increasing the transaction block size"
      ],
      "correct_answer": "D",
      "explanation": "Block size has no relation to TLS channel security.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/security_model.html"
    },
    {
      "question": "What is the main purpose of the Fabric Gateway in Hyperledger Fabric v2.4?",
      "options": [
        "A) To create new blockchain networks",
        "B) To deploy chaincode automatically",
        "C) To manage user identities and access controls",
        "D) To handle endorsements and submit transactions on behalf of client applications"
      ],
      "correct_answer": "D",
      "explanation": "The Gateway off-loads endorse-submit-commit flows from applications, giving simpler client code and optimal peer selection.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/gateway.html"
    },
    {
      "question": "Which of the following steps is combined into a single function called SubmitTransaction in the Fabric Gateway client APIs?",
      "options": [
        "A) Evaluate, Endorse, and Submit",
        "B) Submit, CommitStatus, and Evaluate",
        "C) Endorse, Submit, and CommitStatus",
        "D) Evaluate, CommitStatus, and Receive Chaincode Events"
      ],
      "correct_answer": "C",
      "explanation": "SubmitTransaction performs endorsement, submission to orderer and commit status checking in one call.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/gateway.html"
    },
    {
      "question": "Which of the following describes the 'Evaluate a Transaction Proposal' step in the Fabric Gateway transaction handling process?",
      "options": [
        "A) Calling a smart contract function on one peer and returning the result to the client",
        "B) Waiting for confirmation that the transaction has been committed to the ledger",
        "C) Submitting the signed transaction envelope to the ordering service",
        "D) Collecting enough endorsement responses to meet the required signature policies"
      ],
      "correct_answer": "A",
      "explanation": "Evaluate calls a function on a single peer for read-only operations and returns the payload without committing.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/gateway.html"
    },
    {
      "question": "What is the primary function of Fabric CA in a Hyperledger Fabric network?",
      "options": [
        "A) To manage blockchain transactions",
        "B) To create smart contracts",
        "C) To issue, renew, and revoke digital certificates for network participants",
        "D) To manage data storage on the blockchain"
      ],
      "correct_answer": "C",
      "explanation": "Fabric CA provides PKI services: registration, enrollment, certificate renewal and revocation for users and nodes.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/fabric-ca-commands.html"
    },
    {
      "question": "Which component of Fabric CA is responsible for handling certificate requests and generating cryptographic materials?",
      "options": [
        "A) CA Server",
        "B) CA Client",
        "C) CA Database",
        "D) CA Network"
      ],
      "correct_answer": "A",
      "explanation": "The fabric-ca-server component processes registration/enrollment requests, generating certificates and keys.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/fabric-ca-commands.html"
    },
    {
      "question": "What role does the registerEnroll.sh script play in a Hyperledger Fabric network?",
      "options": [
        "A) It creates channels in the network",
        "B) It configures the network's environment variables",
        "C) It deploys chaincode on the network",
        "D) It registers and enrolls users, peers, and orderers with the Certificate Authority"
      ],
      "correct_answer": "D",
      "explanation": "Sample networks use helper scripts (e.g., registerEnroll.sh) to automate CA registration/enrollment flows.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "What is a Rich Query in Hyperledger Fabric?",
      "options": [
        "A) A simple key-value query",
        "B) A query that can only retrieve data based on asset ID",
        "C) A query that does not support pagination",
        "D) A complex query utilizing CouchDB's query language to filter and retrieve records based on various conditions"
      ],
      "correct_answer": "D",
      "explanation": "Rich queries leverage CouchDB’s JSON selector syntax to filter documents on non-key fields.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/couchdb_tutorial.html"
    },
    {
      "question": "What is a Parameterized Rich Query in Hyperledger Fabric?",
      "options": [
        "A) A query that uses fixed conditions defined during chaincode deployment",
        "B) A query that does not accept any parameters",
        "C) A query that accepts parameters to dynamically construct the query",
        "D) A query that uses SQL syntax for querying"
      ],
      "correct_answer": "C",
      "explanation": "Parameterized rich queries build the selector at runtime using passed-in arguments, avoiding string concatenation inside chaincode.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "How can you query all assets owned by “Tom” using Rich Queries?",
      "options": [
        "A) By executing a command with a static query string",
        "B) By specifying a selector in the query argument to filter by the owner field",
        "C) By directly accessing the state database",
        "D) By using SQL queries in the chaincode"
      ],
      "correct_answer": "B",
      "explanation": "You pass a JSON selector: {\"selector\":{\"owner\":\"Tom\"}} to stub.GetQueryResult.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/key_concepts.html"
    },
    {
      "question": "What is the primary format in which CouchDB stores data?",
      "options": ["A) XML", "B) CSV", "C) Binary", "D) JSON"],
      "correct_answer": "D",
      "explanation": "CouchDB is a document store; each document is JSON.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/couchdb_tutorial.html"
    },
    {
      "question": "Which command is used to start the Hyperledger Fabric network using CouchDB?",
      "options": [
        "A) network.sh start -couchdb",
        "B) ./network.sh up createChannel -s couchdb",
        "C) fabric.sh up couchdb",
        "D) network.sh deploy couchdb"
      ],
      "correct_answer": "B",
      "explanation": "The test-network helper script uses syntax './network.sh up createChannel -s couchdb' to launch peers with CouchDB.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/couchdb_tutorial.html"
    },
    {
      "question": "What is the default port on which CouchDB runs?",
      "options": ["A) 5984", "B) 8080", "C) 27017", "D) 3306"],
      "correct_answer": "A",
      "explanation": "CouchDB listens on TCP 5984 by default.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/couchdb_tutorial.html"
    },
    {
      "question": "What is the primary benefit of using CouchDB as a state database in Hyperledger Fabric over LevelDB?",
      "options": [
        "A) CouchDB provides faster read and write performance",
        "B) CouchDB allows for direct interaction with SQL queries",
        "C) CouchDB is embedded and doesn't require additional setup",
        "D) CouchDB supports JSON queries"
      ],
      "correct_answer": "D",
      "explanation": "Rich JSON selectors and pagination are the key advantage; LevelDB is faster but key-only.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/couchdb_tutorial.html"
    },
    {
      "question": "Identify the function called to initialize the ledger state in the asset transfer chaincode.",
      "options": [
        "A) InitLedger",
        "B) CreateAsset",
        "C) GetAllAssets",
        "D) ReadAsset"
      ],
      "correct_answer": "A",
      "explanation": "InitLedger seeds sample asset data when the chaincode is instantiated.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "Which command sets the path to include the Hyperledger Fabric binaries directory?",
      "options": [
        "A) export PATH=${PWD}/../bin:${PWD}:$PATH",
        "B) export CHANNEL_NAME=mychannel",
        "C) source ./scripts/setOrgPeerContext.sh 1",
        "D) peer chaincode query -C $CHANNEL_NAME -n asset -c '{\"Args\":[\"GetAllAssets\"]}'"
      ],
      "correct_answer": "A",
      "explanation": "The PATH export prepends the Fabric binaries so peer/configtxgen/cryptogen are executable.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "How many arguments are required by the CreateAsset function in the asset transfer chaincode when invoking it from the CLI?",
      "options": ["A) Three", "B) Four", "C) Five", "D) Six"],
      "correct_answer": "C",
      "explanation": "CreateAsset(assetID, color, size, owner, value) expects five arguments.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "Which environment variable sets the path for the chaincode files in the setAssetContext.sh script?",
      "options": [
        "A) export CC_SRC_PATH",
        "B) export CC_RUNTIME_LANGUAGE",
        "C) export VERSION",
        "D) export CHANNEL_NAME"
      ],
      "correct_answer": "A",
      "explanation": "CC_SRC_PATH points to the chaincode source directory.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "Which command is used to package the chaincode in a tar file using the Fabric peer binaries?",
      "options": [
        "A) peer lifecycle chaincode instal",
        "B) peer lifecycle chaincode approveformyorg",
        "C) peer lifecycle chaincode package",
        "D) peer lifecycle chaincode queryinstalled"
      ],
      "correct_answer": "C",
      "explanation": "The 'package' subcommand outputs a .tar.gz containing code.tar.gz and metadata.json.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/peerlifecycle.html"
    },
    {
      "question": "Which type of policy in Hyperledger Fabric allows the creation of complex rules using combinations like AND, OR, and \"N out of M\"?",
      "options": [
        "A) ImplicitMetaPolicy",
        "B) ApplicationPolicy",
        "C) SignaturePolicy",
        "D) OrdererPolicy"
      ],
      "correct_answer": "C",
      "explanation": "Signature policies directly express boolean combinations of principals.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "In the configtx.yaml file, which section is used to set the rules for how peer organizations interact with application channels?",
      "options": [
        "A) Organizations",
        "B) Capabilities",
        "C) Orderer",
        "D) Application"
      ],
      "correct_answer": "D",
      "explanation": "The Application section defines policies (e.g., Readers/Writers/Endorsement) for channel application operations.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/peers/peers.html"
    },
    {
      "question": "Which command is used to generate the genesis block for a new channel in Hyperledger Fabric?",
      "options": [
        "A) peer channel create -c $CHANNEL_NAME -f ./channel-artifacts/${CHANNEL_NAME}.tx",
        "B) orderer channel join -c $CHANNEL_NAME -b ./channel-artifacts/${CHANNEL_NAME}.block",
        "C) peer channel join -b ./channel-artifacts/${CHANNEL_NAME}.block",
        "D) configtxgen -profile ChannelUsingRaft -outputBlock ./channel-artifacts/${CHANNEL_NAME}.block -channelID $CHANNEL_NAME"
      ],
      "correct_answer": "D",
      "explanation": "configtxgen with -outputBlock creates the genesis (channel) block.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "What tool is used for generating cryptographic certificates in a Hyperledger Fabric network?",
      "options": ["A) Fabric SDK", "B) Docker", "C) Cryptogen", "D) OpenSSL"],
      "correct_answer": "C",
      "explanation": "Cryptogen quickly generates development-grade X.509 material for peers/orderers/orgs.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "Identify the command that is used to start the Hyperledger Fabric test network with Docker Compose?",
      "options": [
        "A) docker-compose -f compose/compose-test-net.yaml -f compose/docker/docker-compose-test-net.yaml up",
        "B) docker-compose up",
        "C) cryptogen generate --config",
        "D) fabric-samples/test-network/start.sh"
      ],
      "correct_answer": "D",
      "explanation": "The test-network script start.sh wraps docker-compose files to start the environment.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "Which command is used to download the Hyperledger Fabric samples, binaries, and Docker images?",
      "options": [
        "A) wget https://hyperledger.org/fabric/samples",
        "B) git clone https://github.com/hyperledger/fabric-samples",
        "C) npm install fabric-samples",
        "D) curl -sSLO https://raw.githubusercontent.com/hyperledger/fabric/main/scripts/install-fabric.sh"
      ],
      "correct_answer": "D",
      "explanation": "The install-fabric.sh script downloads samples, binaries and Docker images for a requested version.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "What does the command ./network.sh up createChannel do in Hyperledger Fabric?",
      "options": [
        "A) Brings down the network and creates a new channel",
        "B) Brings up the Fabric network with one channel",
        "C) Deploys chaincode to a channel",
        "D) Lists all Docker containers"
      ],
      "correct_answer": "B",
      "explanation": "The helper script launches orderers/peers/CAs and then creates mychannel by default.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "Which parameter is used to specify the chaincode language when deploying with the ./network.sh deployCC command?",
      "options": ["A) -ccn", "B) -ccp", "C) -ccl", "D) -ccv"],
      "correct_answer": "C",
      "explanation": "The flag -ccl <language> selects go|java|javascript|typescript.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "Which of the following statements about smart contracts is MOST accurate?",
      "options": [
        "A) They define the rules and logic for transactions on a blockchain",
        "B) They are physical contracts stored on a blockchain",
        "C) They are software applications that run independently of a blockchain",
        "D) They require a trusted third party for enforcement"
      ],
      "correct_answer": "A",
      "explanation": "Smart contracts codify business logic and are executed deterministically by endorsing peers.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "Which step in the Fabric Chaincode Lifecycle involves building the smart contract code on each peer?",
      "options": [
        "A) Package Chaincode",
        "B) Peer Installation",
        "C) Organizational Approval",
        "D) Channel Commitment"
      ],
      "correct_answer": "B",
      "explanation": "When a peer receives the .tar.gz it builds the chaincode container image during installation.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode_lifecycle.html"
    },
    {
      "question": "What is the purpose of the Gossip Protocol in Hyperledger Fabric?",
      "options": [
        "A) To validate transactions and generate blocks",
        "B) To securely encrypt data on the ledger",
        "C) To efficiently disseminate information and maintain a consistent network state",
        "D) To establish secure communication channels between peers"
      ],
      "correct_answer": "C",
      "explanation": "Gossip spreads blocks, state and membership info across peers, achieving eventual consistency.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/gossip.html"
    },
    {
      "question": "What happens during the endorsement phase of a transaction lifecycle in Hyperledger Fabric?",
      "options": [
        "A) The ordering service verifies the transaction order",
        "B) Peers commit the transaction to the ledger",
        "C) The transaction is validated and added to a block",
        "D) Peers simulate the transaction execution and create a read/write set"
      ],
      "correct_answer": "D",
      "explanation": "Endorsing peers simulate execution, returning RW sets and signatures.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/peers/peers.html"
    },
    {
      "question": "Why is it important to inspect proposal responses during the transaction lifecycle?",
      "options": [
        "A) To automatically update the ledger with any proposed changes",
        "B) To ensure all endorsing peers agree with the proposed transaction",
        "C) To encrypt the transaction data before committing it to the ledger",
        "D) To grant access permissions to specific users involved in the transaction"
      ],
      "correct_answer": "B",
      "explanation": "Clients must verify all proposal responses match to avoid submitting divergent RW sets.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/key_concepts.html"
    },
    {
      "question": "What is the significance of the ledger update step in the Hyperledger Fabric transaction flow?",
      "options": [
        "A) To temporarily store the transaction details for later processing",
        "B) To authorize the client who initiated the transaction",
        "C) To permanently record the transaction on a shared, immutable ledger",
        "D) To broadcast the transaction to all peers in the network"
      ],
      "correct_answer": "C",
      "explanation": "Commit phase appends the block and updates world state; the ledger becomes the tamper-evident source of truth.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/txflow.html"
    },
    {
      "question": "In Hyperledger Fabric, how does the Ordering Service handle conflicting transactions?",
      "options": [
        "A) It detects conflicts and rejects one of the transactions",
        "B) It orders transactions without detecting conflicts, leaving peers to handle conflicts",
        "C) It prevents conflicts by carefully analyzing transaction data",
        "D) It retries the conflicting transaction until it succeeds"
      ],
      "correct_answer": "B",
      "explanation": "Orderers are content-blind; peers perform MVCC conflict checks during validation.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What is a quorum in the context of the Raft ordering service?",
      "options": [
        "A) The maximum number of ordering nodes that can participate in consensus",
        "B) A specific type of transaction proposal",
        "C) A role assigned to a leader node in Raft",
        "D) The minimum number of ordering nodes required to agree on transactions"
      ],
      "correct_answer": "D",
      "explanation": "Raft requires a majority (quorum) of nodes to replicate a log entry before it is considered committed.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "Why is the Raft ordering service preferred for production networks in Hyperledger Fabric?",
      "options": [
        "A) Provides a balance of efficiency, fault tolerance, and flexibility",
        "B) Offers the highest level of security compared to other options",
        "C) Is the only ordering service currently supported in Hyperledger Fabric",
        "D) Requires minimal configuration and management overhead"
      ],
      "correct_answer": "A",
      "explanation": "Raft is crash-fault-tolerant, easier to operate than Kafka and suitable for high throughput.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What are the primary responsibilities of peers in a Hyperledger Fabric network?",
      "options": [
        "A) To manage user identities and define access permissions",
        "B) To maintain the ledger, validate transactions, and potentially execute smart contracts",
        "C) To order and sequence transactions within a block",
        "D) To act as entry points for clients to submit transactions"
      ],
      "correct_answer": "B",
      "explanation": "Peers hold ledgers, run chaincode, validate blocks and respond to queries.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "How do channels contribute to enhanced confidentiality within a Hyperledger Fabric network?",
      "options": [
        "A) Channels restrict information sharing to authorized participants within a specific channel",
        "B) Channels encrypt all data stored on the ledger",
        "C) Channels allow anonymous transactions on the network",
        "D) Channels define the communication protocol for all peers"
      ],
      "correct_answer": "A",
      "explanation": "Only members of a channel receive blocks and can read private ledger data for that channel.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "How is the ledger structured in Hyperledger Fabric?",
      "options": [
        "A) Composed of blocks (containing historical records) chained together and a world state (current snapshot) that is constantly updated",
        "B) As a single, continuously growing file containing all transactions",
        "C) As a database with tables for each asset type in the network",
        "D) Stored on a central server and replicated to all peers for redundancy"
      ],
      "correct_answer": "A",
      "explanation": "Fabric separates immutable blockchain history from the mutable world-state database.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "What is the primary function of a Membership Service Provider (MSP) in Hyperledger Fabric?",
      "options": [
        "A) To define the rules and policies for membership and identity validation",
        "B) To manage and distribute digital certificates within the network",
        "C) To encrypt and decrypt data during transactions on the blockchain",
        "D) To maintain a record of all transactions on the blockchain ledger"
      ],
      "correct_answer": "A",
      "explanation": "An MSP bundles CA certs, CRLs, config.yaml and rules that peer/orderer nodes use to verify identities.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What is the purpose of a Certificate Revocation List (CRL) in a PKI system?",
      "options": [
        "A) To identify certificates that have been compromised and are no longer valid",
        "B) To list certificates that are nearing their expiration date",
        "C) To identify trusted Certificate Authorities (CAs) within the network",
        "D) To maintain a record of all digital certificates issued by a CA"
      ],
      "correct_answer": "A",
      "explanation": "CRLs enumerate revoked serial numbers so peers/orderers can reject signatures from compromised users.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What are the two main components that make up a digital certificate (X.509 standard) used in Hyperledger Fabric?",
      "options": [
        "A) ECDSA public key and private key of the certificate holder",
        "B) ECDSA public key and certificate authority information",
        "C) ECDSA private key and certificate authority information",
        "D) Digital signature and certificate holder's IP address"
      ],
      "correct_answer": "B",
      "explanation": "An X.509 cert binds a subject’s public key to identity attributes, attested by a CA signature.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/security_model.html"
    },
    {
      "question": "In a hierarchical Certificate Authority (CA) structure, what is the role of a Root CA?",
      "options": [
        "A) To issue certificates directly to end-entities (users or devices)",
        "B) To manage the revocation of certificates within the network",
        "C) To verify the certificates issued by Intermediate CAs",
        "D) To be the most trusted CA in the hierarchy, issuing certificates to all other CAs"
      ],
      "correct_answer": "D",
      "explanation": "The root CA sits at the trust anchor, signing the certificates for intermediate CAs which then enroll end entities.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/fabric-ca-commands.html"
    },
    {
      "question": "What is the significance of assets in Hyperledger Fabric?",
      "options": [
        "A) Assets represent valuable items tracked and managed on the blockchain",
        "B) Assets define the type of cryptocurrency used on the networkp",
        "C) Assets are virtual machines used to run smart contracts",
        "D) Assets specify the communication protocols used by peers"
      ],
      "correct_answer": "A",
      "explanation": "Assets (key-value pairs) capture business objects—physical or digital— whose state transitions are governed by chaincode.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "How does Hyperledger Fabric achieve access control for sensitive data?",
      "options": [
        "A) By granting read/write access to all participants",
        "B) By storing data in a completely encrypted format",
        "C) By using a public permissionless blockchain model",
        "D) By implementing MSPs and channel-based permissions"
      ],
      "correct_answer": "D",
      "explanation": "MSPs verify identities and channel policies enforce read/write or endorsement rights.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/msp.html"
    },
    {
      "question": "Hyperledger Fabric uses cryptographic hashing for several purposes. Which of the following best illustrates how hashing contributes to the blockchain's tamper resistance and data integrity?",
      "options": [
        "A) Encrypting transaction data so only authorized participants can view it",
        "B) Enforcing access control to private data collections by hashing participants' identities",
        "C) Generating unique identifiers for transactions and linking blocks securely within the chain",
        "D) Providing a method to encode private keys for secure wallet management"
      ],
      "correct_answer": "C",
      "explanation": "Each block header stores the hash of the previous block header; altering a block changes its hash and breaks the chain.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/security_model.html"
    },
    {
      "question": "Which project is primarily designed to facilitate interoperability between multiple blockchain networks?",
      "options": [
        "A) Hyperledger Cacti",
        "B) Hyperledger Fabric",
        "C) Hyperledger FireFly",
        "D) Hyperledger Indy"
      ],
      "correct_answer": "A",
      "explanation": "Hyperledger Cacti (successor of Quilt/Burrow) focuses on cross-ledger interoperability and asset transfer.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "What is the primary focus of the Hyperledger Aries project?",
      "options": [
        "A) Building a high-performance blockchain platform",
        "B) Creating a framework for secure and interoperable digital credentials",
        "C) Providing a secure and scalable Ethereum client",
        "D) Connecting isolated blockchain networks for data exchange"
      ],
      "correct_answer": "B",
      "explanation": "Aries supplies agent frameworks and protocols for verifiable credentials atop Indy/DID ledgers.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "What is the primary use case of Hyperledger Indy?",
      "options": [
        "A) Managing assets in a permissioned network",
        "B) Enabling interoperability between different blockchain networks",
        "C) Providing a platform for building Web3 applications",
        "D) Building decentralized identity solutions with self-sovereign identity management"
      ],
      "correct_answer": "D",
      "explanation": "Indy provides ledger and crypto primitives optimized for self-sovereign identity.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "Which of the following best describes the network on which Hyperledger Fabric operates?",
      "options": [
        "A) Permissionless network, where anyone can join",
        "B) Permissioned network, where only authorized participants can join",
        "C) Fully private network, with no access for external users",
        "D) Public-private hybrid network"
      ],
      "correct_answer": "B",
      "explanation": "Fabric is designed for permissioned consortium networks with PKI-verified identities.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "What is the key advantage of Hyperledger Fabric's \"execute-order-validate\" transaction processing method?",
      "options": [
        "A) It allows anyone to participate in the network",
        "B) It eliminates the need for a central authority",
        "C) It improves transaction processing speed and reliability",
        "D) It simplifies the process of mining cryptocurrency"
      ],
      "correct_answer": "C",
      "explanation": "Parallel execution before ordering removes deterministic-execution bottlenecks and reduces transaction rejection after ordering.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "How does Hyperledger Fabric address data privacy concerns for enterprises?",
      "options": [
        "A) It provides no specific mechanisms for data privacy",
        "B) It offers channels and private data collections for secure information sharing",
        "C) All transactions are publicly viewable on the blockchain",
        "D) It requires mandatory use of cryptocurrency for transactions"
      ],
      "correct_answer": "B",
      "explanation": "Channels isolate ledgers, and collections protect key-value pairs while still providing hashes for auditability.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "Why is Hyperledger Fabric a good fit for supply chain management applications?",
      "options": [
        "A) It enables secure and transparent tracking of goods movement",
        "B) It offers complete anonymity for all participants in the network",
        "C) It prioritizes high transaction fees for enhanced security",
        "D) It requires minimal computing power for efficient operation"
      ],
      "correct_answer": "A",
      "explanation": "Fabric’s permissioned visibility, rich queries and asset transfer logic match traceability needs across many organizations.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "Which of the following statements about transaction latency in Hyperledger Fabric is TRUE?",
      "options": [
        "A) Higher latency is always desirable for improved security",
        "B) Simpler chaincode logic typically leads to lower latency",
        "C) Network congestion has no impact on transaction latency",
        "D) The number of peers in a network does not affect latency"
      ],
      "correct_answer": "B",
      "explanation": "Transaction latency is affected by chaincode complexity, network conditions, and the number of endorsing peers. Simpler chaincode executes faster, leading to lower latency.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "Which of the following statements about Hyperledger Fabric is TRUE?",
      "options": [
        "A) It is a decentralized identity framework for self-sovereign identity",
        "B) It is a high-performance Ethereum client designed for private deployments",
        "C) It is a modular and versatile platform for permissioned blockchain networks",
        "D) It is a universal toolkit for building secure and interoperable digital credentials"
      ],
      "correct_answer": "C",
      "explanation": "Hyperledger Fabric is a permissioned, modular, and extensible platform designed for enterprise blockchain solutions, allowing for pluggable components like consensus and state databases.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What is the purpose of pagination in Rich Queries?",
      "options": [
        "A) To handle large datasets by breaking the results into smaller, manageable chunks",
        "B) To execute queries without conditions",
        "C) To limit the number of queries executed per second",
        "D) To store query results permanently"
      ],
      "correct_answer": "A",
      "explanation": "Pagination in CouchDB Rich Queries is used to manage large result sets by returning data in pages, which improves performance and prevents resource exhaustion.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/couchdb_tutorial.html"
    },
    {
      "question": "Which tool is commonly used for monitoring the performance and health of a Hyperledger Fabric network?",
      "options": ["A) Prometheus", "B) Hadoop", "C) MySQL", "D) Apache Spark"],
      "correct_answer": "A",
      "explanation": "Hyperledger Fabric exposes an operations service with a /metrics endpoint that is designed to be scraped by Prometheus for monitoring network health and performance.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/operations_service.html"
    },
    {
      "question": "Which file is used to define the configuration for a Private Data Collection in Hyperledger Fabric?",
      "options": [
        "A) collections_config.json",
        "B) core.yaml",
        "C) configtx.yaml",
        "D) docker-compose.yaml"
      ],
      "correct_answer": "A",
      "explanation": "A JSON file, commonly named collections_config.json, is used to define private data collection policies, including name, members, blockToLive, and endorsement requirements. This file is passed during chaincode instantiation or upgrade.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "What will happen if you try to update an asset using a peer endorsement from an organization that does not currently own the asset, assuming state-based endorsement is being used?",
      "options": [
        "A) The update will succeed, but ownership of the asset will be reassigned",
        "B) The update will fail with an endorsement policy failure, as only the asset owner’s peers can endorse the transaction",
        "C) The transaction will be accepted, but the asset's state will remain unchanged",
        "D) The transaction will succeed if the invoking organization is an admin"
      ],
      "correct_answer": "B",
      "explanation": "With state-based endorsement, the endorsement policy is tied to the asset's state on the ledger. If the policy requires the owner's endorsement, any transaction endorsed by a non-owner peer will fail validation.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html"
    },
    {
      "question": "What is the primary role of Anchor Peers in the Hyperledger Fabric network?",
      "options": [
        "A) To execute and endorse transactions",
        "B) To facilitate communication and information sharing between organizations",
        "C) To order and sequence transactions within a block",
        "D) To manage user identities and define access permissions"
      ],
      "correct_answer": "B",
      "explanation": "Anchor peers are discoverable by peers in other organizations and are essential for enabling cross-organization gossip communication, allowing peers to learn about the network state of other members.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/peers/peers.html"
    },
    {
      "question": "How do channels in Hyperledger Fabric contribute to data privacy?",
      "options": [
        "A) Channels encrypt all data stored on the ledger",
        "B) Channels restrict information sharing to authorized participants",
        "C) Channels allow anonymous transactions on the network",
        "D) Channels define the communication protocol for all peers"
      ],
      "correct_answer": "B",
      "explanation": "Channels create private subnets within the broader network, ensuring that only the authenticated and authorized members of that channel can see its transactions and ledger data, thereby providing confidentiality.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "What component of Hyperledger Fabric uses CouchDB as an optional state database?",
      "options": [
        "A) Certificate Authority",
        "B) Channel",
        "C) Orderer",
        "D) Peer"
      ],
      "correct_answer": "D",
      "explanation": "A Hyperledger Fabric Peer node is responsible for maintaining the state database. While LevelDB is the default, CouchDB can be configured as an alternative to enable rich JSON queries.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/couchdb_tutorial.html"
    },
    {
      "question": "What is the first step in the chaincode deployment lifecycle in a Hyperledger Fabric network?",
      "options": ["A) Approve", "B) Install", "C) Package", "D) Commit"],
      "correct_answer": "C",
      "explanation": "The chaincode lifecycle follows the sequence: 1. Package, 2. Install, 3. Approve, 4. Commit. The first step is to package the chaincode source code into a .tar.gz file.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/peerlifecycle.html"
    },
    {
      "question": "The phases of the transaction process in Hyperledger fabric include transaction proposal and endorsement, transaction submission and ordering, and transaction validation and commitment. True or False?",
      "options": ["A) True", "B) False"],
      "correct_answer": "A",
      "explanation": "This statement accurately describes the three phases of the execute-order-validate transaction flow in Hyperledger Fabric.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/txflow.html"
    },
    {
      "question": "Which databases are supported by Fabric CA for storing issued certificates, revocation lists, and user information?",
      "options": [
        "A) SQLite, MySQL, and PostgreSQL",
        "B) Oracle, MongoDB, and CouchDB",
        "C) Firebase, MariaDB, and SQL Server",
        "D) HBase, Neo4j, and Cassandra"
      ],
      "correct_answer": "A",
      "explanation": "The Fabric CA server can be configured to use a relational database backend. It supports SQLite (the default), PostgreSQL, and MySQL.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/fabric-ca-commands.html"
    },
    {
      "question": "During the organizational approval stage of the chaincode lifecycle, what is typically being voted on?",
      "options": [
        "A) Whether to join a specific channel",
        "B) The specific programming language used for the smart contract",
        "C) The endorsement policy for the smart contract",
        "D) The transaction fees associated with using the smart contract"
      ],
      "correct_answer": "C",
      "explanation": "When an organization approves a chaincode definition, it is agreeing to the proposed parameters, which critically include the chaincode version, sequence number, and endorsement policy.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html"
    },
    {
      "question": "Which command is used to delete an asset in the Hyperledger Fabric ledger?",
      "options": [
        "A) peer chaincode query -C mychannel -n asset -c '{\"Args\":[\"DeleteAsset\",\"asset11\"]}'",
        "B) peer chaincode invoke -C mychannel -n asset -c '{\"function\":\"DeleteAsset\",\"Args\":[\"asset11\"]}'",
        "C) peer chaincode query -C mychannel -n asset -c '{\"Args\":[\"ReadAsset\",\"asset11\"]}'",
        "D) peer chaincode invoke -C mychannel -n asset -c '{\"function\":\"RemoveAsset\",\"Args\":[\"asset11\"]}'"
      ],
      "correct_answer": "B",
      "explanation": "Deleting an asset modifies the world state, so it must be done via a transaction submitted with 'peer chaincode invoke'. Querying only reads the ledger without changing it.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "Which command is used to install the chaincode on the peers of an organization?",
      "options": [
        "A) peer lifecycle chaincode install",
        "B) peer lifecycle chaincode package",
        "C) peer lifecycle chaincode approveformyorg",
        "D) peer lifecycle chaincode commit"
      ],
      "correct_answer": "A",
      "explanation": "'peer lifecycle chaincode install' takes a packaged chaincode file and installs it on the peer, making the chaincode binaries available for execution.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/peerlifecycle.html"
    },
    {
      "question": "What is a key benefit of Hyperledger Fabric's modular architecture for enterprises?",
      "options": [
        "A) It allows businesses to customize the platform to their specific needs",
        "B) It offers a single, fixed set of functionalities",
        "C) It requires minimal technical expertise to implement",
        "D) It prioritizes anonymity for all network participants"
      ],
      "correct_answer": "A",
      "explanation": "Fabric's modularity allows enterprises to plug in their preferred components for identity (MSP), consensus (Raft, BFT), and state database (LevelDB, CouchDB), tailoring the network to specific requirements.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What is a key advantage of private, permissioned blockchains like Hyperledger Fabric compared to public blockchains?",
      "options": [
        "A) Increased decentralization and open participation",
        "B) Faster transaction processing and scalability",
        "C) Enhanced security through public scrutiny",
        "D) Greater transparency for all participants"
      ],
      "correct_answer": "B",
      "explanation": "Because permissioned blockchains operate in a more trusted environment with known participants and often use more efficient consensus mechanisms (like Raft), they can achieve higher transaction throughput and lower latency than public chains.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "How do Local MSPs and Channel MSPs differ in Hyperledger Fabric?",
      "options": [
        "A) Local MSPs are for peers, while Channel MSPs are for orderers",
        "B) Local MSPs handle authentication, while Channel MSPs handle authorization",
        "C) Local MSPs define permissions for a node's local users (e.g., its admin), while Channel MSPs define an organization's permissions within a channel",
        "D) Local MSPs are temporary, while Channel MSPs are permanent"
      ],
      "correct_answer": "C",
      "explanation": "The Local MSP (LMSP) governs permissions for that specific node (e.g., who can administer the peer). The Channel MSP (CMSP) defines the identity and roles of an organization at the channel level, verifying its rights to read, write, or manage the channel.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/msp.html"
    },
    {
      "question": "What is the purpose of the BatchSize settings in the Orderer section of the configtx.yaml file?",
      "options": [
        "A) To control the maximum block size and how often a new block is created",
        "B) To set the maximum number of transactions in a block",
        "C) To determine the minimum number of organizations required to approve a transaction",
        "D) To define the hashing algorithm used for new blocks"
      ],
      "correct_answer": "A",
      "explanation": "The BatchSize settings, which include MaxMessageCount, AbsoluteMaxBytes, and PreferredMaxBytes, control how many transactions can be in a block and the block's maximum size, thus influencing when a new block is 'cut'.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "To tolerate F Byzantine (malicious) failures, a SmartBFT ordering service requires a minimum of how many nodes?",
      "options": ["A) 2F + 1", "B) F + 1", "C) 3F + 1", "D) 4F + 1"],
      "correct_answer": "C",
      "explanation": "All classic Byzantine Fault Tolerant consensus protocols, including SmartBFT, require a minimum of 3F + 1 nodes to guarantee correctness and liveness in the presence of F malicious or faulty nodes.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "In a peer's core.yaml, what does the `peer.gossip.externalEndpoint` setting define?",
      "options": [
        "A) The internal address for peer-to-peer communication within the same organization.",
        "B) The address and port of the anchor peers in other organizations.",
        "C) The endpoint that this peer advertises to peers in other organizations for cross-organization gossip.",
        "D) The address of the ordering service for the peer to connect to."
      ],
      "correct_answer": "C",
      "explanation": "The `externalEndpoint` is critical for cross-organization communication. It's the address that this peer makes public to the rest of the channel members outside its own org, allowing them to establish a gossip connection.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },

    {
      "question": "What is the purpose of the `TLSHandshakeTimeShift` parameter in a peer's or orderer's configuration?",
      "options": [
        "A) To set the network-wide time for TLS certificate timestamps.",
        "B) To account for time zone differences between nodes.",
        "C) To allow for a grace period when a TLS certificate has expired, to prevent connection failures due to clock skew.",
        "D) To force a TLS handshake every time a new connection is made."
      ],
      "correct_answer": "C",
      "explanation": "If a node's TLS certificate has expired but the system clocks are slightly out of sync, `TLSHandshakeTimeShift` provides a buffer (e.g., 30s) to temporarily allow the connection, preventing network disruption while certificates are being renewed.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "In a Raft ordering service with 5 nodes, what is the maximum number of nodes that can fail while still maintaining quorum and processing transactions?",
      "options": ["A) 1", "B) 2", "C) 3", "D) 4"],
      "correct_answer": "B",
      "explanation": "A Raft cluster of N nodes can tolerate (N-1)/2 failures. For N=5, it can tolerate (5-1)/2 = 2 failures. A quorum of 3 nodes is still available to operate.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "When using the `configtxgen` tool, what does the `-asOrg` flag specify?",
      "options": [
        "A) The organization that will be the channel administrator.",
        "B) The organization that is submitting the transaction to create the channel.",
        "C) The name of the output file for the channel configuration.",
        "D) It specifies which organization's MSP material should be used to sign the configuration transaction."
      ],
      "correct_answer": "D",
      "explanation": "The `-asOrg` flag tells `configtxgen` to use the specified organization's MSP context to cryptographically sign the generated channel artifact, proving the action was taken by a legitimate member.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/msp.html"
    },
    {
      "question": "Which API call in a smart contract is used to set a state-based endorsement policy for a specific key?",
      "options": [
        "A) `ctx.stub.setEndorsementPolicy(key, policy)`",
        "B) `ctx.stub.setStateEndorsement(key, policy)`",
        "C) `ctx.stub.setStateValidationParameter(key, policyBytes)`",
        "D) `ctx.stub.setKeyPolicy(key, policyBytes)`"
      ],
      "correct_answer": "C",
      "explanation": "The `setStateValidationParameter()` function is used to set the endorsement policy for a specific key-value pair, enabling state-based endorsement. The policy itself is provided as a byte array.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html"
    },
    {
      "question": "What is a key difference between `DelPrivateData` and `PurgePrivateData` in a chaincode?",
      "options": [
        "A) `DelPrivateData` deletes from CouchDB, while `PurgePrivateData` deletes from LevelDB.",
        "B) `DelPrivateData` is temporary, while `PurgePrivateData` is permanent.",
        "C) `DelPrivateData` marks the data for deletion but leaves it in the private database, while `PurgePrivateData` completely removes all traces of it.",
        "D) `DelPrivateData` removes the key from the world state, while `PurgePrivateData` also removes the corresponding hash from the public blockchain."
      ],
      "correct_answer": "C",
      "explanation": "`DelPrivateData` creates a delete marker but the data remains in the private database of peers who had it, accessible for a period defined by `blockToLive`. `PurgePrivateData` is an irreversible operation that completely erases the data from the private state.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "When an orderer starts without a system channel (channel participation API), which tool is used to make it join an application channel?",
      "options": [
        "A) `peer channel join`",
        "B) `configtxlator`",
        "C) `osnadmin channel join`",
        "D) `cryptogen`"
      ],
      "correct_answer": "C",
      "explanation": "The `osnadmin` CLI is the designated tool for administering an ordering service node that is not bootstrapped with a system channel. The `osnadmin channel join` command is used to fetch a channel's genesis block and make the orderer join it.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/create_channel/create_channel_participation.html"
    },
    {
      "question": "In the Fabric CA server configuration, what is the purpose of the `affiliations` section?",
      "options": [
        "A) To list all the organizations that are members of the channel.",
        "B) To define a hierarchical structure of departments or business units within an organization, controlling which registrars can issue identities.",
        "C) To specify which other Certificate Authorities this CA is affiliated with.",
        "D) To list the IP addresses of affiliated peers and orderers."
      ],
      "correct_answer": "B",
      "explanation": "Affiliations create a tree-like structure (e.g., `org1.department1`). When a registrar is created with an affiliation, they can only register new identities within that branch of the tree, enforcing organizational structure on identity creation.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/fabric-ca-commands.html"
    },
    {
      "question": "What does the `peer.gossip.pvtData.pullRetryThreshold` setting in `core.yaml` control?",
      "options": [
        "A) The number of times a peer will try to connect to an anchor peer.",
        "B) The number of times a peer will attempt to pull missing private data from other peers before giving up.",
        "C) The time to wait before retrying to send a block to the ordering service.",
        "D) The threshold for how many private data hashes can be stored in memory."
      ],
      "correct_answer": "B",
      "explanation": "This parameter defines the resilience of private data dissemination. It specifies how many times a peer will try to fetch private data it has a hash for but is missing the corresponding payload from its collection members.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "In Hyperledger Fabric v2.5+, what is the recommended and default consensus mechanism for production environments?",
      "options": ["A) Kafka", "B) Solo", "C) Raft", "D) SmartBFT"],
      "correct_answer": "C",
      "explanation": "Raft is the recommended crash fault-tolerant (CFT) consensus protocol since Fabric v2.0, completely replacing Kafka. SmartBFT was introduced later in v3.0 as a BFT option, but Raft remains the default CFT choice.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "When packaging a Go chaincode, what does the `META-INF/statedb/couchdb/indexes` directory contain?",
      "options": [
        "A) The chaincode source code for CouchDB.",
        "B) A list of all keys stored in the CouchDB state database.",
        "C) The connection details for the CouchDB instance.",
        "D) JSON index definitions that will be automatically deployed to CouchDB to support rich queries."
      ],
      "correct_answer": "D",
      "explanation": "To ensure efficient rich queries, CouchDB requires indexes. By placing index definition files (`.json`) in this specific directory within the chaincode package, Fabric will automatically deploy them to the peer's CouchDB instance when the chaincode is installed.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/peerlifecycle.html"
    },
    {
      "question": "What is the primary function of an Intermediate CA in a Fabric network's certificate hierarchy?",
      "options": [
        "A) To act as a backup for the Root CA.",
        "B) To issue certificates to peers and users without exposing the Root CA's private key.",
        "C) To validate transactions on behalf of the Root CA.",
        "D) To store a copy of all certificates issued in the network."
      ],
      "correct_answer": "B",
      "explanation": "In a production environment, the Root CA is kept offline for maximum security. It issues a certificate for an Intermediate CA, which is then brought online to handle the day-to-day issuance of enrollment certificates for nodes and users, protecting the root of trust.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/security_model.html"
    },
    {
      "question": "Which of the following endorsement policy syntaxes is valid for requiring a signature from BOTH Org1 and Org2?",
      "options": [
        "A) `OR('Org1.member', 'Org2.member')`",
        "B) `OutOf(2, 'Org1.member', 'Org2.member')`",
        "C) `AND('Org1.member', 'Org2.member')`",
        "D) `MAJORITY('Org1.member', 'Org2.member')`"
      ],
      "correct_answer": "C",
      "explanation": "The `AND` operator in an endorsement policy requires all of its arguments to be satisfied. `AND('Org1.member', 'Org2.member')` means that a valid signature from a member of Org1 AND a valid signature from a member of Org2 are required.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html"
    },
    {
      "question": "Which file generated by the `cryptogen` tool contains the private key for a user or peer?",
      "options": [
        "A) `ca.crt`",
        "B) `signcerts/cert.pem`",
        "C) `cacerts/ca.pem`",
        "D) `keystore/priv_sk`"
      ],
      "correct_answer": "D",
      "explanation": "The `cryptogen` tool generates MSP directories. Within each node's or user's MSP folder, the `keystore` directory contains the private key, which is a file that typically has `_sk` in its name.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/msp.html"
    },
    {
      "question": "In the `configtx.yaml` file, what does the `ModPolicy` for the Application group typically default to?",
      "options": [
        "A) `Admins`",
        "B) `Writers`",
        "C) `Readers`",
        "D) `Majority Admins`"
      ],
      "correct_answer": "D",
      "explanation": "The modification policy (`ModPolicy`) for the Application group, which controls adding/removing orgs or changing application policies, typically defaults to requiring a majority of the existing organization Admins to approve the change.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "What happens if a client submits a transaction proposal to a peer that is not a member of the specified channel?",
      "options": [
        "A) The peer will forward the request to a peer that is a member of the channel.",
        "B) The transaction will be endorsed but will fail at the validation stage.",
        "C) The peer will reject the proposal with an error indicating it is not a member of the channel.",
        "D) The peer will process the transaction but will not be able to commit it to the ledger."
      ],
      "correct_answer": "C",
      "explanation": "A peer maintains a separate ledger for each channel it belongs to. If it receives a proposal for a channel it has not joined, it cannot access that channel's ledger or chaincode and will immediately reject the request.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "The Fabric Gateway service, introduced in v2.4, simplifies client applications by performing which two key functions?",
      "options": [
        "A) Packaging and installing chaincode.",
        "B) Endorsement gathering and transaction submission.",
        "C) User registration and enrollment.",
        "D) Channel creation and block generation."
      ],
      "correct_answer": "B",
      "explanation": "The Gateway service acts as a trusted proxy. The client only needs to submit a proposal to the Gateway, which then handles the entire endorsement-gathering process from the required peers and submits the endorsed transaction to the ordering service on the client's behalf.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/gateway.html"
    },
    {
      "question": "What is the role of the `CORE_PEER_CHAINCODEADDRESS` environment variable?",
      "options": [
        "A) It specifies the address of the chaincode container for the peer to connect to.",
        "B) It defines the listening address for the peer's chaincode service.",
        "C) When using an external builder, it tells the peer where to connect to the chaincode service.",
        "D) It sets the public address of the chaincode for client applications."
      ],
      "correct_answer": "C",
      "explanation": "In production, it's common to use an external builder to run chaincode in a separate environment (e.g., Kubernetes pods). `CORE_PEER_CHAINCODEADDRESS` tells the peer the address:port of this external chaincode service, overriding the default behavior of the peer launching its own Docker container.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "Which health check endpoint in the peer's operations service can be used by orchestrators like Kubernetes to determine if the peer is alive?",
      "options": [
        "A) `/health/live`",
        "B) `/status/liveness`",
        "C) `/healthz`",
        "D) `/operations/is_alive`"
      ],
      "correct_answer": "C",
      "explanation": "The `/healthz` endpoint is the standard health check URL. It returns a `200 OK` status with a JSON payload indicating the status of the peer and its joined channels. This is commonly used for liveness probes.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "Which statement accurately describes the difference between `peer node start` and `peer node pause`?",
      "options": [
        "A) `pause` stops the peer process, while `start` restarts it.",
        "B) `pause` temporarily stops all chaincode containers, while `start` resumes them.",
        "C) There is no `peer node pause` command; you can only start and stop a peer.",
        "D) `pause` suspends all gossip and transaction processing but keeps the peer process running, while `start` resumes it."
      ],
      "correct_answer": "C",
      "explanation": "The `peer node` command only has a `start` subcommand to launch the peer process. There are no native `pause`, `resume`, or `stop` commands in the `peer` CLI; these actions are typically managed through the container runtime (e.g., `docker stop`).",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/key_concepts.html"
    },
    {
      "question": "When using the `fabric-ca-client`, what is the purpose of the `--caname` flag during enrollment?",
      "options": [
        "A) To specify the name of the user being enrolled.",
        "B) To name the certificate file that will be generated.",
        "C) To specify which CA to connect to when the Fabric CA server is configured to host multiple CAs.",
        "D) To set the Common Name (CN) inside the generated certificate."
      ],
      "correct_answer": "C",
      "explanation": "A single Fabric CA server process can host multiple Certificate Authorities, each with its own signing key and database. The `--caname` flag on the client side directs the request to the intended CA hosted by that server.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/fabric-ca-commands.html"
    },
    {
      "question": "What is the default value for a private data collection's `blockToLive` property if it is not specified?",
      "options": [
        "A) 1000",
        "B) 100",
        "C) It is mandatory and has no default.",
        "D) 0 (meaning the data is never purged)"
      ],
      "correct_answer": "D",
      "explanation": "If the `blockToLive` parameter is omitted from the collection configuration, it defaults to 0. A value of 0 means the private data will be stored indefinitely on the peers and will never be automatically purged.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "What is the purpose of the `configtxlator` tool?",
      "options": [
        "A) To translate chaincode from one programming language to another.",
        "B) To generate the initial genesis block and channel transaction artifacts.",
        "C) To convert Fabric configuration formats (like protobuf) to a human-readable format (JSON) and back.",
        "D) To automatically create and deploy a Hyperledger Fabric network."
      ],
      "correct_answer": "C",
      "explanation": "The `configtxlator` (Configuration Transaction Translator) is a utility that helps with updating channel configurations. It can decode binary protobuf config blocks into JSON, allow users to edit them, and then encode them back into the protobuf format required by Fabric.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "According to the official documentation, which chaincode language generally exhibits the lowest performance and highest resource consumption?",
      "options": [
        "A) Go",
        "B) JavaScript/TypeScript (Node.js)",
        "C) Java",
        "D) Python"
      ],
      "correct_answer": "C",
      "explanation": "Performance benchmarks in the Fabric documentation consistently show that Go chaincode is the most performant, followed by Node.js. Java chaincode, due to the overhead of the JVM, typically has the highest latency and resource usage.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "Which of the following is NOT a valid `msp.IdentityClassification` in the MSP configuration?",
      "options": ["A) PEER", "B) ORDERER", "C) CLIENT", "D) VALIDATOR"],
      "correct_answer": "D",
      "explanation": "The MSP configuration in `core.yaml` or `orderer.yaml` uses classifications like PEER, ORDERER, CLIENT, and ADMIN to define the roles of identities. VALIDATOR is not a recognized identity classification in this context.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "A channel's block-cutting parameters are `BatchTimeout: 2s`, `MaxMessageCount: 10`, `PreferredMaxBytes: 512KB`. What will happen if 9 transactions (totaling 100KB) are received by the orderer?",
      "options": [
        "A) A block will be cut immediately with the 9 transactions.",
        "B) A block will be cut after 2 seconds containing the 9 transactions.",
        "C) The orderer will wait for a 10th transaction before cutting a block.",
        "D) The orderer will wait until the total size reaches 512KB."
      ],
      "correct_answer": "B",
      "explanation": "A block is cut when ANY of the three conditions are met. In this case, neither `MaxMessageCount` (10) nor `PreferredMaxBytes` (512KB) has been reached. Therefore, the `BatchTimeout` of 2 seconds will be the trigger to cut the block.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "When a peer is started, it reads its configuration from a `core.yaml` file. What is the primary way to override a setting in this file without modifying it directly?",
      "options": [
        "A) Using command-line flags when starting the peer.",
        "B) Sending a configuration update transaction to the channel.",
        "C) Setting an environment variable with a specific naming convention.",
        "D) Editing a separate `override.yaml` file."
      ],
      "correct_answer": "C",
      "explanation": "Fabric uses a specific convention to map YAML configuration keys to environment variables. For example, `peer.gossip.useLeaderElection` can be overridden by setting the environment variable `CORE_PEER_GOSSIP_USELEADERELECTION=true`. This is the standard method used in Docker and Kubernetes deployments.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/gossip.html"
    },
    {
      "question": "What is the primary advantage of using ledger snapshots in Hyperledger Fabric v2.3+?",
      "options": [
        "A) To reduce transaction processing time",
        "B) To allow peers to join channels from a specific block height without processing all historical blocks",
        "C) To encrypt private data more efficiently",
        "D) To enable cross-channel communication"
      ],
      "correct_answer": "B",
      "explanation": "Ledger snapshots allow new peers to join channels from a specific block height, avoiding the need to process all blocks since genesis, which saves time and resources especially for channels with extensive transaction history.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "Which limitation applies when a peer joins a channel using a ledger snapshot?",
      "options": [
        "A) The peer cannot endorse transactions for 24 hours",
        "B) Private data is not included in snapshots",
        "C) The peer must be from the same organization as the snapshot creator",
        "D) Snapshots can only be taken by orderer nodes"
      ],
      "correct_answer": "B",
      "explanation": "Private data is not included in ledger snapshots as stated in the official documentation. Peers joined via snapshots also cannot query or endorse transactions before the snapshot block height.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "In Hyperledger Fabric v3.0, what is the minimum number of nodes required for SmartBFT consensus to tolerate one Byzantine failure?",
      "options": ["A) 3 nodes", "B) 4 nodes", "C) 5 nodes", "D) 7 nodes"],
      "correct_answer": "B",
      "explanation": "SmartBFT requires 3f+1 nodes to tolerate f Byzantine failures. To tolerate 1 Byzantine failure, you need 3(1)+1 = 4 nodes minimum.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What is the measured performance of SmartBFT integrated into Hyperledger Fabric v3.0 for a 4-node deployment?",
      "options": [
        "A) 1,000 transactions per second",
        "B) 2,000 transactions per second",
        "C) 3,000 transactions per second",
        "D) 5,000 transactions per second"
      ],
      "correct_answer": "B",
      "explanation": "According to official documentation, SmartBFT integrated into Fabric has been measured at 2,000 transactions per second for a 4-node deployment, though this can vary based on hardware and network conditions.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "Which command is used to take a ledger snapshot at a specific block height?",
      "options": [
        "A) peer ledger snapshot -c mychannel -b 1000",
        "B) peer snapshot submitrequest -c mychannel -b 1000",
        "C) peer channel snapshot -c mychannel --height 1000",
        "D) peer ledger backup -c mychannel -b 1000"
      ],
      "correct_answer": "B",
      "explanation": "The correct command is 'peer snapshot submitrequest -c <channel> -b <block_height>' to request a snapshot at a specific block height.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "What is the primary purpose of Hardware Security Modules (HSMs) in Hyperledger Fabric?",
      "options": [
        "A) To increase transaction throughput",
        "B) To store private keys in tamper-resistant hardware and handle cryptographic operations",
        "C) To provide backup storage for ledger data",
        "D) To encrypt channel communications"
      ],
      "correct_answer": "B",
      "explanation": "HSMs protect private keys in tamper-resistant hardware and handle cryptographic operations, allowing nodes to sign transactions without exposing private keys, which is critical for FIPS 140-2 compliance.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/security_model.html"
    },
    {
      "question": "Which PKCS standard does Hyperledger Fabric use to communicate with HSMs?",
      "options": ["A) PKCS#1", "B) PKCS#7", "C) PKCS#11", "D) PKCS#12"],
      "correct_answer": "C",
      "explanation": "Fabric leverages the PKCS#11 standard to communicate with Hardware Security Modules for cryptographic operations.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/security_model.html"
    },
    {
      "question": "In the context of External Builders, what does the 'detect' script determine?",
      "options": [
        "A) Whether the chaincode package can be built by this external builder",
        "B) The programming language of the chaincode",
        "C) The endorsement policy requirements",
        "D) The network connectivity status"
      ],
      "correct_answer": "A",
      "explanation": "The 'detect' script in an external builder determines whether the chaincode package is recognized and can be built by that particular external builder.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/commands/peerlifecycle.html"
    },
    {
      "question": "What is Chaincode as a Service (CCaaS) in Hyperledger Fabric v2.4+?",
      "options": [
        "A) A cloud hosting service for chaincode",
        "B) A deployment model where chaincode runs as an external service rather than in peer-managed containers",
        "C) A marketplace for purchasing chaincode",
        "D) A debugging tool for smart contracts"
      ],
      "correct_answer": "B",
      "explanation": "CCaaS allows chaincode to run as an external service (e.g., Kubernetes pods) that peers connect to, rather than peers managing the chaincode containers directly.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "Which environment variable must be propagated to external builders for Kubernetes deployments?",
      "options": [
        "A) KUBERNETES_NAMESPACE",
        "B) KUBERNETES_SERVICE_HOST",
        "C) KUBERNETES_CLUSTER_NAME",
        "D) KUBERNETES_API_VERSION"
      ],
      "correct_answer": "B",
      "explanation": "KUBERNETES_SERVICE_HOST (along with KUBERNETES_SERVICE_PORT) must be propagated to external builders to enable communication with the Kubernetes API.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/cc_service.html"
    },
    {
      "question": "What is the primary benefit of the Service Discovery feature in Hyperledger Fabric?",
      "options": [
        "A) To automatically deploy chaincode",
        "B) To dynamically discover network topology, peers, and endorsement policies without static configuration",
        "C) To monitor network performance",
        "D) To manage user identities"
      ],
      "correct_answer": "B",
      "explanation": "Service Discovery allows client applications to dynamically discover network topology, active peers, orderers, and endorsement policies, eliminating the need for static configuration files.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "Which API endpoint is used by Service Discovery to provide network information?",
      "options": [
        "A) /gossip/discovery",
        "B) /peer/discovery",
        "C) The discovery service runs as part of the peer's gRPC interface",
        "D) /network/topology"
      ],
      "correct_answer": "C",
      "explanation": "Service Discovery is integrated into the peer's gRPC interface and uses the same port as other peer services, not a separate REST endpoint.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/discovery-overview.html"
    },
    {
      "question": "In the Channel Participation API (v2.3+), which osnadmin command is used to make an orderer join a channel without a system channel?",
      "options": [
        "A) osnadmin channel create",
        "B) osnadmin channel join",
        "C) osnadmin channel add",
        "D) osnadmin channel participate"
      ],
      "correct_answer": "B",
      "explanation": "The 'osnadmin channel join' command allows an orderer to join an application channel directly without requiring a system channel.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/create_channel/create_channel_participation.html"
    },
    {
      "question": "What is the default location where peer ledger snapshots are stored?",
      "options": [
        "A) /var/hyperledger/snapshots/",
        "B) /var/hyperledger/production/snapshots/",
        "C) /opt/fabric/snapshots/",
        "D) /tmp/ledger-snapshots/"
      ],
      "correct_answer": "B",
      "explanation": "By default, completed snapshots are stored in '/var/hyperledger/production/snapshots/{channelname}/completed/{blocknumber}/' within the peer container.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "Which operations service endpoint provides health check information for Fabric nodes?",
      "options": ["A) /health", "B) /healthz", "C) /status", "D) /alive"],
      "correct_answer": "B",
      "explanation": "The '/healthz' endpoint is the standard health check URL that returns the health status of the peer and its joined channels.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/channels.html"
    },
    {
      "question": "What is the purpose of the 'EXTERNAL_ENDPOINT' configuration for peers in service discovery?",
      "options": [
        "A) To set the peer's admin interface address",
        "B) To define the address that other organizations can use to connect to this peer",
        "C) To configure the peer's database connection",
        "D) To set the peer's logging output destination"
      ],
      "correct_answer": "B",
      "explanation": "EXTERNAL_ENDPOINT defines the address that peers from other organizations can use to connect to this peer for gossip communication and service discovery.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/gossip.html"
    },
    {
      "question": "In SmartBFT consensus, what is the trade-off compared to other PBFT implementations?",
      "options": [
        "A) Higher memory usage but lower CPU usage",
        "B) No pipelining capability but reduced complexity",
        "C) Faster consensus but less security",
        "D) More network traffic but better fault tolerance"
      ],
      "correct_answer": "B",
      "explanation": "SmartBFT sacrifices pipelining performance (leaders can only propose one block at a time) in exchange for reduced complexity and easier implementation/integration.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What cryptographic signature scheme is recommended for IoT devices interacting with Hyperledger Fabric v3.0?",
      "options": [
        "A) RSA-2048",
        "B) ECDSA P-256",
        "C) FROST threshold signatures",
        "D) Ed25519"
      ],
      "correct_answer": "C",
      "explanation": "Recent research shows FROST (Flexible Round-Optimized Schnorr Threshold) signatures can enable IoT device networks to interact with Fabric v3.0, completing signatures in approximately 3.2 seconds for a 5-device network.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/security_model.html"
    },
    {
      "question": "Which configuration parameter controls phantom read detection in Hyperledger Fabric's MVCC validation?",
      "options": [
        "A) peer.validation.phantomReads",
        "B) chaincode.phantomReadCheck",
        "C) Phantom read detection is automatic and cannot be configured",
        "D) ledger.state.phantomValidation"
      ],
      "correct_answer": "C",
      "explanation": "Phantom read detection is built into Fabric's MVCC validation process and re-executes range queries automatically during validation. It cannot be disabled or configured.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "What is the primary limitation of using SoftHSM for production Hyperledger Fabric deployments?",
      "options": [
        "A) It doesn't support PKCS#11",
        "B) It's a software-based emulator, not a true hardware security module",
        "C) It only works with specific chaincode languages",
        "D) It requires special licenses"
      ],
      "correct_answer": "B",
      "explanation": "SoftHSM is a software-based implementation for development and testing. Production environments requiring FIPS 140-2 compliance need actual hardware-based HSMs.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "In Fabric's external builder architecture, what is the purpose of the 'release' script?",
      "options": [
        "A) To build the chaincode from source",
        "B) To launch the built chaincode",
        "C) To provide metadata about how to run the built chaincode",
        "D) To clean up build artifacts"
      ],
      "correct_answer": "C",
      "explanation": "The 'release' script provides metadata (connection information, TLS certificates, etc.) that tells the peer how to connect to and run the externally built chaincode.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "Which peer configuration parameter controls the maximum number of concurrent transactions that can be in the gossip message buffer?",
      "options": [
        "A) peer.gossip.maxBlockCountToStore",
        "B) peer.gossip.election.leaderElectionDuration",
        "C) peer.gossip.pvtData.pullRetryThreshold",
        "D) peer.gossip.batch.maxConcurrency"
      ],
      "correct_answer": "C",
      "explanation": "The 'pullRetryThreshold' parameter in gossip private data configuration controls how many times a peer will attempt to pull missing private data before giving up.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html"
    },
    {
      "question": "What happens to the transaction if a peer's HSM becomes unavailable during transaction endorsement?",
      "options": [
        "A) The transaction is automatically retried with a different peer",
        "B) The endorsement fails and the transaction cannot be signed",
        "C) The peer switches to software-based signing",
        "D) The transaction is queued until the HSM is available"
      ],
      "correct_answer": "B",
      "explanation": "If the HSM becomes unavailable, the peer cannot access its private key to sign endorsements, causing the endorsement process to fail.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/peers/peers.html"
    },
    {
      "question": "In Fabric v3.0's SmartBFT, how are block signatures collected for verification by other system components?",
      "options": [
        "A) Signatures are embedded in the block header",
        "B) Block finalization collects signatures from a majority of nodes",
        "C) Only the leader node signs blocks",
        "D) Signatures are stored separately in a signature database"
      ],
      "correct_answer": "B",
      "explanation": "SmartBFT's block finalization process collects signatures from a majority of nodes, allowing other system components to verify block authenticity without participating in consensus directly.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "What is the recommended approach for upgrading a Fabric network from Raft to SmartBFT consensus?",
      "options": [
        "A) Direct in-place upgrade during network operation",
        "B) The upgrade requires a network restart and is not seamless",
        "C) Use the channel participation API to migrate orderers",
        "D) SmartBFT cannot replace existing Raft deployments"
      ],
      "correct_answer": "B",
      "explanation": "Upgrading from Raft to SmartBFT requires careful planning and network restart as it involves changing the fundamental consensus mechanism, which cannot be done seamlessly during operation.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    },
    {
      "question": "Which component is responsible for block validation in the Channel Participation API model?",
      "options": [
        "A) System channel orderers",
        "B) Individual participating orderers",
        "C) Peer nodes only",
        "D) Certificate Authority"
      ],
      "correct_answer": "B",
      "explanation": "In the Channel Participation API model without system channels, each participating orderer is responsible for validating channel configuration and blocks for the channels it has joined.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/create_channel/create_channel_participation.html"
    },
    {
      "question": "What is the primary security benefit of using external chaincode launchers in Kubernetes?",
      "options": [
        "A) Faster chaincode execution",
        "B) Elimination of the need for peers to have Docker daemon access",
        "C) Automatic chaincode updates",
        "D) Built-in load balancing"
      ],
      "correct_answer": "B",
      "explanation": "External launchers eliminate the security risk of peers requiring Docker daemon access, which requires root-level privileges that may not be acceptable in production environments.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html"
    },
    {
      "question": "In Fabric's FabMAN (Fabric Management) approach for IoT applications, what does the adaptive algorithm optimize?",
      "options": [
        "A) Network bandwidth usage",
        "B) Batch size and batch timeout to optimize ledger growth",
        "C) Consensus voting patterns",
        "D) Private data collection policies"
      ],
      "correct_answer": "B",
      "explanation": "FabMAN's adaptive algorithm dynamically adjusts batch size and batch timeout parameters to optimize ledger growth rate based on incoming transaction proposal rates, particularly important for resource-constrained IoT environments.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html"
    },
    {
      "question": "What validation occurs when using the Channel Participation API to join an orderer to a channel?",
      "options": [
        "A) Only certificate validation",
        "B) The orderer validates the channel genesis block and configuration",
        "C) Peer endorsement is required",
        "D) System channel admin approval is needed"
      ],
      "correct_answer": "B",
      "explanation": "When using the Channel Participation API, the orderer validates the channel genesis block and configuration to ensure it can properly participate in the channel's consensus process.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/create_channel/create_channel_participation.html"
    },
    {
      "question": "According to Fabric documentation, what is the maximum recommended value for AbsoluteMaxBytes in orderer configuration?",
      "options": ["A) 10 MB", "B) 49 MB", "C) 98 MB", "D) 100 MB"],
      "correct_answer": "B",
      "explanation": "The maximum recommended AbsoluteMaxBytes is 49 MB, based on the need for headroom under the default gRPC max message size of 100 MB to account for additional metadata and envelope overhead.",
      "documentation_url": "https://hyperledger-fabric.readthedocs.io/en/latest/orderer/ordering_service.html"
    }
  ]
}
